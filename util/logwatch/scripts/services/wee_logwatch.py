#!/usr/bin/env python
#
#    Copyright (c) 2009-2020 Tom Keffer <tkeffer@gmail.com>
#
#    See the file LICENSE.txt for your full rights.
#
"""A Python based logwatch script to process WeeWX logs.

Description:

    This script has been will analyse and report on WeeWX log entries as a plug
    in module to the logwatch monitoring system. The script distributed as part
    of the WeeWX package is aware of log entries generated by the WeeWX code
    base only. The script can be extended to analyse and report on WeeWX log
    entries generated by WeeWX extensions and add ons.

    As well as being used by logwatch the script can also be executed directly
    with a log or other text file as the source. Whilst the power of the
    logwatch monitoring system is not available when this script is run
    directly, running the script directly is useful when extending the script
    to process log entries from WeeWX extensions and add ons.

Compatibility:
    This script can process log entries from WeeWX 4.0 and later. WeeWX 3.x log
    entries can be processed but will likely result in many unmatched lines
    being reported.

Operation:

    Class WeeWXLogwatchEngine manages the analysis and reporting of the log
    entries. The actual processing and report generation is performed by one or
    more object based on class LogwatchProcessor. Class WeeWXLogwatchProcessor
    is based on class LogwatchProcessor and processes and reports on all log
    entries produced by the WeeWX code base. Additional user defined classes
    based on class LogwatchProcessor can be include in /home/weewx/logwatch or
    /etc/weewx/logwatch to include the processing of log entries from
    extensions/add ons.

    Each processor object uses a config dict that defines the regular
    expressions used for analysing the log entries and the report
    layout/content. The regexs can be broken down into:

    - The ignore list, a list of regexs that match log entries that will be ignored.
    - Increments, regexs for which a match will result in a variable being incremented by one.
    - Sums, regexs for which a match will capture a number that will be added to a running total.
    - Itemised, regexs for which a match will capture one or more pieces of data from the log entry.

    The report layout/content config can be broken down into:

    - Summary counts, a simple tabular display of a label followed by a number, data is typically obtained from the Increments or Sums regexxs
    - Itemised reports, a hybrid layout that by default includes summary type contents followed by associated log entries

    The script relies on two classes, class WeeWXLogwatchEngine and class
    LogwatchProcessor, and a config file. Class WeeWXLogwatchEngine controls the
    ingestion of log entries and generation of the WeeWX logwatch report
    through one or more objects based on class LogwatchProcessor.
    Class Logwatch filter ingests log lines and contributes to the WeeWX
    logwatch report for log lines that are in its vocabulary. For example, one
    LogwatchProcessor object may know how to recognise, interpret and report on
    log entries from a standard WeeWX install, another LogwatchProcessor object
    may know how to recognise, interpret and report on log entries from the
    Forecasting extension and yet another object could be used to handle the
    cmon extension log entries. In this was the WeeWX logwatch script can be
    extended to handle any log entries generated by a customised WeeWX
    installation.

    The WeeWX logwatch script is complete with everything needed to analyse and
    report on the WeeWX log entries generated by a default WeeWX install but can be
    extended via the WeeWX logwatch config file. Amongst other things, the WeeWX
    logwatch config file can be used to alter existing or define new regular
    expressions used for analysing log file entries as well as to alter existing
    or define new report segments.

    The WeeWX logwatch script is structured such that

    The logwatch filers rely on the known structure of the log entries and use
    regular expressions to search log entry lines for matching text. Regular
    expressions can be constructed in a manner to extract counts or other data
    for use in reports.

Extending the WeeWX logwatch script:


"""
# TODO. Add wmr300 line 1291 log.info( "During history read, %d loop data packets were ignored" % loop_ignored )
# TODO. Review cc3000 regexs and report specification
# TODO. Review wmr200 regexs and report specification
# TODO. Review wmr300 regexs and report specification
# TODO. Review ws1 regexs and report specification
# TODO. Review ws23xx regexs and report specification
# TODO. Review ws28xx regexs and report specification

# Python imports
from __future__ import absolute_import
from __future__ import print_function

import optparse
import os
import re
import sys
import time

from configobj import ConfigObj

# WeeWX logwatch script version
WEEWX_LOGWATCH_VERSION = "0.1.0"

WEEWX_LOGWATCH_CONFIG_DEFAULT = {
    'ingest': {
        'ignore': ["Starting weewx weather system",
                   "Stopping weewx weather system: weewx.",
                   "Reloading weewx weather system: weewx.",
                   "__main__: Initializing weewx version",
                   "__main__: Using Python",
                   "__main__: Platform",
                   "__main__: Locale is",
                   "__main__: Waiting for sane time",
                   "__main__: PID file is ",
                   "__main__: Using configuration file",
                   "__main__: Debug is",
                   "__main__: Initializing engine",
                   "__main__: \*\*\*\*  Waiting 60 seconds then retrying",
                   "__main__: Terminating weewx version",
                   "weewx\.engine: Loading station type",
                   "weewx\.engine: No services in service group",
                   "weewx\.engine: Loading service",
                   "weewx\.engine: Finished loading service",
                   "weewx\.engine: Starting main packet loop",
                   "weewx\.engine: Main loop exiting. Shutting engine down.",
                   "weewx\.engine: StdConvert target unit is",
                   "weewx\.engine: No calibration information in config file. Ignored.",
                   "weewx\.engine: Archive will use data binding",
                   "weewx\.engine: Record generation will be attempted in",
                   "weewx\.engine: Using archive interval of",
                   "weewx\.engine: Use LOOP data in hi/low calculations",
                   "weewx\.engine: Using binding",
                   "weewx\.engine: No catchup specified",
                   "weewx\.engine: Station does not support setting the time",
                   "weewx\.engine: Station does not support reading the time",
                   "weewx\.engine: Shutting down StdReport thread",
                   "weewx\.engine: StdReport thread has been terminated",
                   "weewx\.cheetahgenerator: Using search list",
                   "weewx\.cheetahgenerator: Skip ",
                   "weewx\.imagegenerator: Skip ",
                   "weewx\.manager: Created and initialized table",
                   "weewx\.manager: Daily summary version is",
                   "weewx\.manager: Created daily summary tables",
                   "weewx\.manager: Starting backfill of daily summaries",
                   "weewx\.manager: Processed \d+ records to backfill",
                   "weewx\.manager: Daily summaries up to date",
                   "weewx\.manager: Created and initialized table",
                   "weewx\.reportengine: Running reports for time",
                   "weewx\.reportengine: Running reports for latest time in the database",
                   "weewx\.reportengine: Report '[a-zA-Z0-9-_]+' not enabled. Skipping.",
                   "weewx\.reportengine: Running report",
                   "weewx\.reportengine: Report '[a-zA-Z0-9-_]+' skipped due to report_timing setting",
                   "weewx\.reportengine: No generators specified for report",
                   "weewx\.reportengine: Found configuration file",
                   "weewx\.reportengine: ftpgenerator: FTP upload not requested. Skipped.",
                   "weewx\.reportengine: rsyncgenerator: Rsync upload not requested. Skipped.",
                   "weewx\.database: maxwindspeed: This is a dry run.",
                   "weewx\.database: maxwindspeed: Using database binding",
                   "weewx\.database: maxwindspeed: Database transactions will use",
                   "weewx\.database: maxwindspeed: Applying",
                   "weewx\.database: maxwindspeed: Maximum windSpeed calculated",
                   "weewx\.database: maxwindspeed: This was a dry run.",
                   "weewx\.database: intervalweighting: This is a dry run.",
                   "weewx\.database: intervalweighting: Using database binding",
                   "weewx\.database: intervalweighting: Database transactions",
                   "weewx\.database: intervalweighting: .+ not applied",
                   "weewx\.database: intervalweighting: Multiple distinct 'interval'",
                   "weewx\.database: intervalweighting: .+ will be applied by dropping",
                   "weewx\.database: intervalweighting: .+ has already been applied",
                   "weewx\.database: intervalweighting: Applying ",
                   "weewx\.database: intervalweighting: Calculated weighting",
                   "weewx\.database: intervalweighting: This was a dry run",
                   "weewx\.database: intervalweighting: .+ has already been applied",
                   "weewx\.database: intervalweighting: Checking table",
                   "weewx\.database: intervalweighting: Successfully checked",
                   "weewx\.database: intervalweighting: Processed .+ consisting of \d+ records.",
                   "weewx\.restx: Shut down .+ thread",
                   "weewx\.restx: No database specified. Augmentation from database skipped.",
                   "weewx\.restx: .+: Skipped record",
                   "weewx\.restx: .+: record .+ is stale",
                   "weewx\.restx: wait interval [()0-9<]+ has not passed for record",
                   "weewx\.restx: WU essentials:",
                   "weewx\.restx: Wunderground-PWS: Data for station",
                   "weewx\.restx: Wunderground-RF: Data for station",
                   "weewx\.restx: Raw packet:",
                   "weewx\.restx: Cached packet:",
                   "weewx\.restx: PWSWeather: Data for station",
                   "weewx\.restx: WOW: Data for station",
                   "weewx\.restx: Ambient: url: ",
                   "weewx\.restx: WOW: url: ",
                   "weewx\.restx: CWOP: Data for station",
                   "weewx\.restx: CWOP: packet: ",
                   "weewx\.restx: : Connected to server",
                   "weewx\.restx: StationRegistry: Registration not requested.",
                   "weewx\.restx: StationRegistry: Station will be registered.",
                   "weewx\.restx: StationRegistry: wait interval",
                   "weewx\.restx: AWEKAS: Data will be uploaded for user",
                   "weewx\.restx: AWEKAS: No database specified. Augmentation from database skipped.",
                   "weewx\.restx: AWEKAS: url: ",
                   "weewx\.restx: .+: Posting not enabled",
                   "weewx\.wxservices: The following values will be calculated:",
                   "weewx\.wxservices: The following algorithms will be used for calculations:",
                   "weeutil\.ftpupload: Attempting secure connection to",
                   "weeutil\.ftpupload: Attempting connection to",
                   "weeutil\.ftpupload: Secure data connection to",
                   "weeutil\.ftpupload: Connected to",
                   "weeutil\.ftpupload: Made directory",
                   "weeutil\.rsyncupload: rsyncupload: cmd:",
                   "weeutil\.rsyncupload: rsync executed in",
                   "weewx\.drivers\.vantage: Gentle wake up of console successful",
                   "weewx\.drivers\.vantage: Rude wake up of console successful",
                   "weewx\.drivers\.vantage: Unable to wake up console\.\.\.",
                   "weewx\.drivers\.vantage: Opened up serial port",
                   "weewx\.drivers\.vantage: Opened up ethernet host",
                   "weewx\.drivers\.vantage: Driver version is",
                   "weewx\.drivers\.vantage: Hardware name:",
                   "weewx\.drivers\.vantage: Requesting \d+ LOOP packets",
                   "weewx\.drivers\.vantage: Getting archive packets since",
                   "weewx\.drivers\.vantage: Getting all archive packets",
                   "weewx\.drivers\.vantage: Retrieving \d+ page\(s\); starting index=",
                   "weewx\.drivers\.vantage: Empty record page",
                   "weewx\.drivers\.vantage: DMPAFT complete: page timestamp [a-zA-Z0-9() :-]+ less than final timestamp",
                   "weewx\.drivers\.vantage: Catch up complete",
                   "weewx\.drivers\.vantage: Dumping all records",
                   "weewx\.drivers\.vantage: Starting logger summary",
                   "weewx\.drivers\.vantage: Vantage: Finished logger summary",
                   "weewx\.drivers\.vantage: Hardware type is",
                   "weewx\.drivers\.vantage: ISS ID is",
                   "weewx\.drivers\.fousb: got rainfall of",
                   "weewx\.drivers\.fousb: Power off port ",
                   "weewx\.drivers\.fousb: Power on port ",
                   "weewx\.drivers\.fousb: Waiting 30 seconds for station to power down",
                   "weewx\.drivers\.fousb: Waiting 60 seconds for station to power up",
                   "weewx\.drivers\.fousb: driver version is",
                   "weewx\.drivers\.fousb: power cycling enabled for port",
                   "weewx\.drivers\.fousb: polling mode is",
                   "weewx\.drivers\.fousb: polling interval is",
                   "weewx\.drivers\.fousb: found station on USB bus=",
                   "weewx\.drivers\.fousb: found \d+ archive records",
                   "weewx\.drivers\.fousb: returning archive record",
                   "weewx\.drivers\.fousb: get \d+ records since",
                   "weewx\.drivers\.fousb: synchronising to the weather station \(quality=",
                   "weewx\.drivers\.fousb: packet timestamp is",
                   "weewx\.drivers\.fousb: log timestamp is",
                   "weewx\.drivers\.fousb: delay ",
                   "weewx\.drivers\.fousb: status ",
                   "weewx\.drivers\.fousb: new data",
                   "weewx\.drivers\.fousb: live synchronised",
                   "weewx\.drivers\.fousb: new ptr: ",
                   "weewx\.drivers\.fousb: log synchronised",
                   "weewx\.drivers\.fousb: log extended",
                   "weewx\.drivers\.fousb: avoid ",
                   "weewx\.drivers\.fousb: waiting for ack",
                   "weewx\.drivers\.acurite: driver version is",
                   "weewx\.drivers\.acurite: R2 will be decoded using sensor constants",
                   "weewx\.drivers\.acurite: R2 bounds on constants will be ignored",
                   "weewx\.drivers\.acurite: R3 data will be attempted",
                   "weewx\.drivers\.acurite: R1: ",
                   "weewx\.drivers\.acurite: R2: ",
                   "weewx\.drivers\.acurite: R3: ",
                   "weewx\.drivers\.acurite: next read in ",
                   "weewx\.drivers\.acurite: Found station at bus=",
                   "weewx\.drivers\.cc3000: Driver version is",
                   "weewx\.drivers\.cc3000: Using serial port",
                   "weewx\.drivers\.cc3000: Polling interval is",
                   "weewx\.drivers\.cc3000: Using \S+ time for loop packets",
                   "weewx\.drivers\.cc3000: Sensor map is",
                   "weewx\.drivers\.cc3000: Clear logger at",
                   "weewx\.drivers\.cc3000: Firmware:",
                   "weewx\.drivers\.cc3000: Archive interval:",
                   "weewx\.drivers\.cc3000: Header:",
                   "weewx\.drivers\.cc3000: Units:",
                   "weewx\.drivers\.cc3000: Channel:",
                   "weewx\.drivers\.cc3000: Charger status:",
                   "weewx\.drivers\.cc3000: Memory:",
                   "weewx\.drivers\.cc3000: now: [\d,.]+, polling_interval:",
                   "weewx\.drivers\.cc3000: Next polling event in",
                   "weewx\.drivers\.cc3000: Values:",
                   "weewx\.drivers\.cc3000: Parsed:",
                   "weewx\.drivers\.cc3000: No rain in packet:",
                   "weewx\.drivers\.cc3000: Packet:",
                   "weewx\.drivers\.cc3000: No data from sensors",
                   "weewx\.drivers\.cc3000: Logger is at \d+ records",
                   "weewx\.drivers\.cc3000: Clearing all records from logger",
                   "weewx\.drivers\.cc3000: GenStartupRecords: since_ts=",
                   "weewx\.drivers\.cc3000: Downloading new records \(if any\)",
                   "weewx\.drivers\.cc3000: No rain in record:",
                   "weewx\.drivers\.cc3000: Downloaded \d+ new records",
                   "weewx\.drivers\.cc3000: Found checksum at",
                   "weewx\.drivers\.cc3000: Calculated checksum",
                   "weewx\.drivers\.cc3000: Open serial port",
                   "weewx\.drivers\.cc3000: Close serial port",
                   "weewx\.drivers\.cc3000: Write: '",
                   "weewx\.drivers\.cc3000: Read: '",
                   "weewx\.drivers\.cc3000: Flush input buffer",
                   "weewx\.drivers\.cc3000: Flush output buffer",
                   "weewx\.drivers\.cc3000: \S+: The resetting of timeout to \d+ took",
                   "weewx\.drivers\.cc3000: \S+: times:",
                   "weewx\.drivers\.cc3000: \S+: Accepting empty string as cmd echo.",
                   "weewx\.drivers\.cc3000: Get firmware version",
                   "weewx\.drivers\.cc3000: Set echo to",
                   "weewx\.drivers\.cc3000: Get header",
                   "weewx\.drivers\.cc3000: Get time",
                   "weewx\.drivers\.cc3000: Get daylight saving",
                   "weewx\.drivers\.cc3000: Get units",
                   "weewx\.drivers\.cc3000: Get logging interval",
                   "weewx\.drivers\.cc3000: Get channel",
                   "weewx\.drivers\.cc3000: Get charger",
                   "weewx\.drivers\.cc3000: Get baro",
                   "weewx\.drivers\.cc3000: Get memory status",
                   "weewx\.drivers\.cc3000: Get max values",
                   "weewx\.drivers\.cc3000: Get min values",
                   "weewx\.drivers\.cc3000: Clear memory",
                   "weewx\.drivers\.cc3000: Get rain total",
                   "weewx\.drivers\.cc3000: gen_records_since_ts: Asking for all records.",
                   "weewx\.drivers\.cc3000: gen_records_since_ts: Asking for \d+ records.",
                   "weewx\.drivers\.cc3000: gen_records\(\d+\)",
                   "weewx\.drivers\.cc3000: gen_records: Requested \d+ latest of \d+ records.",
                   "weewx\.drivers\.cc3000: DOWNLOAD",
                   "weewx\.drivers\.cc3000: Reading all records into memory.  This could take some time.",
                   "weewx\.drivers\.cc3000: Reading \d+ records into memory.",
                   "weewx\.drivers\.cc3000: Finished reading \d+ records.",
                   "weewx\.drivers\.cc3000: Downloaded \d+ records",
                   "weewx\.drivers\.te923: driver version is",
                   "weewx\.drivers\.te923: polling interval is",
                   "weewx\.drivers\.te923: sensor map is",
                   "weewx\.drivers\.te923: logger capacity",
                   "weewx\.drivers\.te923: station time is",
                   "weewx\.drivers\.te923: reading records from logger since",
                   "weewx\.drivers\.te923: read \d+ records from logger",
                   "weewx\.drivers\.te923: TH\d+  ",
                   "weewx\.drivers\.te923: UVX  ",
                   "weewx\.drivers\.te923: PRS  ",
                   "weewx\.drivers\.te923: WGS  ",
                   "weewx\.drivers\.te923: WSP  ",
                   "weewx\.drivers\.te923: WDR  ",
                   "weewx\.drivers\.te923: RAIN ",
                   "weewx\.drivers\.te923: WCL  ",
                   "weewx\.drivers\.te923: STT  ",
                   "weewx\.drivers\.te923: Found device on USB bus",
                   "weewx\.drivers\.te923: write: ",
                   "weewx\.drivers\.te923: read: ",
                   "weewx\.drivers\.te923: Waiting \d+ seconds before retry",
                   "weewx\.drivers\.te923: MEM  BUF[1]=",
                   "weewx\.drivers\.te923: detected [a-z]+ memory size",
                   "weewx\.drivers\.te923: [0-9a-f]{2,3} : [0-9a-f]{2,3}",
                   "weewx\.drivers\.te923: VER  BUF[1]=",
                   "weewx\.drivers\.te923: VER  bar=",
                   "weewx\.drivers\.te923: BAT  BUF[1]=",
                   "weewx\.drivers\.te923: BAT  rain=",
                   "weewx\.drivers\.te923: ALT  ",
                   "weewx\.drivers\.te923: LOC  ",
                   "weewx\.drivers\.te923: HIS  BUF[3]=",
                   "weewx\.drivers\.te923: record_index=",
                   "weewx\.drivers\.te923: count=",
                   "weewx\.drivers\.te923: gen_records: since_ts",
                   "weewx\.drivers\.te923: gen_records: yield",
                   "weewx\.drivers\.te923: gen_records: reading",
                   "weewx\.drivers\.te923: get_record at address",
                   "weewx\.drivers\.te923: REC  ",
                   "weewx\.drivers\.te923: get_record: found record",
                   "weewx\.drivers\.ultimeter: Driver version is",
                   "weewx\.drivers\.ultimeter: Using serial port",
                   "weewx\.drivers\.ultimeter: Open serial port",
                   "weewx\.drivers\.ultimeter: Close serial port",
                   "weewx\.drivers\.ultimeter: Station time: day:",
                   "weewx\.drivers\.ultimeter: Station said:",
                   "weewx\.drivers\.wmr9x8: Opened up serial port",
                   "weewx\.drivers\.wmr9x8: driver version is",
                   "weewx\.drivers\.wmr9x8: sensor map is",
                   "weewx\.drivers\.wmr9x8: Received WMR9x8 data packet",
                   "weewx\.drivers\.wmr9x8: Advancing buffer by one for the next potential packet",
                   "weewx\.drivers\.wmr9x8: wmr9x8: Running genLoopPackets",
                   "weewx\.drivers\.wmr100: Driver version is",
                   "weewx\.drivers\.wmr100: Sensor map is",
                   "weewx\.drivers\.wmr200: read_device\(\):",
                   "weewx\.drivers\.wmr200: write_device\(\):",
                   "weewx\.drivers\.wmr200: Processing ",
                   "weewx\.drivers\.wmr200:  Packet cooked:",
                   "weewx\.drivers\.wmr200: Time drift between host and console in seconds:",
                   "weewx\.drivers\.wmr200: Using pc time adjusting archive record time by",
                   "weewx\.drivers\.wmr200:   Archive packet num_temp_sensors:",
                   "weewx\.drivers\.wmr200:   Wind Dir:",
                   "weewx\.drivers\.wmr200:   Gust:",
                   "weewx\.drivers\.wmr200:   Windchill:",
                   "weewx\.drivers\.wmr200:   Rain packets:",
                   "weewx\.drivers\.wmr200:   Rain rate:",
                   "weewx\.drivers\.wmr200:   Total rain_total:",
                   "weewx\.drivers\.wmr200:   Last rain ",
                   "weewx\.drivers\.wmr200:   adjust_rain rain_total:",
                   "weewx\.drivers\.wmr200:   Initializing [^\t\n\r\f\v]+.rain_total_last to",
                   "weewx\.drivers\.wmr200:   UV index:",
                   "weewx\.drivers\.wmr200:   Forecast:",
                   "weewx\.drivers\.wmr200:   Raw pressure:",
                   "weewx\.drivers\.wmr200:   Altitude corrected pressure:",
                   "weewx\.drivers\.wmr200:   Temperature id:",
                   "weewx\.drivers\.wmr200:   Humidity id:",
                   "weewx\.drivers\.wmr200:   Dew point id:",
                   "weewx\.drivers\.wmr200:   Heat id:",
                   "weewx\.drivers\.wmr200:  Sensor packet:",
                   "weewx\.drivers\.wmr200: Skipped bytes before resync:",
                   "weewx\.drivers\.wmr200: Created watchdog thread to poke for live data every",
                   "weewx\.drivers\.wmr200: Started watchdog thread live data",
                   "weewx\.drivers\.wmr200: Watchdog received",
                   "weewx\.drivers\.wmr200: Watchdog thread exiting",
                   "weewx\.drivers\.wmr200: Created USB polling thread to read block on device",
                   "weewx\.drivers\.wmr200: USB polling device thread for live data launched",
                   "weewx\.drivers\.wmr200: USB polling device thread signaled to start",
                   "weewx\.drivers\.wmr200: USB polling device thread exiting",
                   "weewx\.drivers\.wmr200: Flushed USB device",
                   "weewx\.drivers\.wmr200: driver version is",
                   "weewx\.drivers\.wmr200: sensor map is",
                   "weewx\.drivers\.wmr200: Configuration setup",
                   "weewx\.drivers\.wmr200:   Log sensor faults:",
                   "weewx\.drivers\.wmr200:   Using PC Time:",
                   "weewx\.drivers\.wmr200:   Erase archive data:",
                   "weewx\.drivers\.wmr200:   Archive interval: ",
                   "weewx\.drivers\.wmr200:   Archive threshold:",
                   "weewx\.drivers\.wmr200: Poked device for live data",
                   "weewx\.drivers\.wmr200: Packet archive queue len:",
                   "weewx\.drivers\.wmr200: Packet raw:",
                   "weewx\.drivers\.wmr200:   Queuing live packet rx:",
                   "weewx\.drivers\.wmr200:   Queuing archive packet rx:",
                   "weewx\.drivers\.wmr200:   Acknowledged control packet rx:",
                   "weewx\.drivers\.wmr200: genLoop\(\) phase getting live packets",
                   "weewx\.drivers\.wmr200: genLoop\(\) Yielding live queued packet id:",
                   "weewx\.drivers\.wmr200: genArchive\(\) phase getting archive packets since",
                   "weewx\.drivers\.wmr200: genArchive\(\) Yielding received archive record after requested timestamp",
                   "weewx\.drivers\.wmr200: genStartup\(\) phase getting archive packets since",
                   "weewx\.drivers\.wmr200: genStartup\(\) Database initialization",
                   "weewx\.drivers\.wmr200: genStartup\(\) Delaying archive packet processing until live packet received",
                   "weewx\.drivers\.wmr200: genStartup\(\) Still receiving archive packets cnt",
                   "weewx\.drivers\.wmr200: genStartup\(\) Yielding received archive record cnt:",
                   "weewx\.drivers\.wmr200: genStartup\(\) phase exiting",
                   "weewx\.drivers\.wmr200: genStartup\(\) Yielded \d+ packets in",
                   "weewx\.drivers\.wmr200: genStartup\(\) Average packets per minute:",
                   "weewx\.drivers\.wmr200: USB polling thread expired",
                   "weewx\.drivers\.wmr200: Watchdog thread expired",
                   "weewx\.drivers\.wmr200: Driver gracefully exiting",
                   "weewx\.drivers\.wmr200: sensors: ",
                   "weewx\.drivers\.wmr200: fields: ",
                   "weewx\.drivers\.wmr300: driver version is",
                   "weewx\.drivers\.wmr300: usb info:",
                   "weewx\.drivers\.wmr300: sensor map is",
                   "weewx\.drivers\.wmr300: history limit is",
                   "weewx\.drivers\.wmr300: communication established:",
                   "weewx\.drivers\.wmr300: init_comm: send initial heartbeat",
                   "weewx\.drivers\.wmr300: init_comm: try to read",
                   "weewx\.drivers\.wmr300: init_comm: send initialization",
                   "weewx\.drivers\.wmr300: init_comm: try to read",
                   "weewx\.drivers\.wmr300: initialization completed in",
                   "weewx\.drivers\.wmr300: init history attempt \d+ of",
                   "weewx\.drivers\.wmr300: init history cmd=",
                   "weewx\.drivers\.wmr300: init history completed after attempt",
                   "weewx\.drivers\.wmr300: finish history attempt",
                   "weewx\.drivers\.wmr300: finish history completed after attempt",
                   "weewx\.drivers\.wmr300: dump history",
                   "weewx\.drivers\.wmr300: (Clearing|Reading) records since",
                   "weewx\.drivers\.wmr300: New historical record for",
                   "weewx\.drivers\.wmr300: History read completed:", # maybe count?
                   "weewx\.drivers\.wmr300: History read in progress:"
                   "weewx\.drivers\.wmr300: skip record ",
                   "weewx\.drivers\.wmr300: got packet ",
                   "weewx\.drivers\.wmr300: ignored packet type",
                   "weewx\.drivers\.wmr300: request station status:",
                   "weewx\.drivers\.wmr300: get history complete:",
                   "weewx\.drivers\.wmr300: get history in progress:",
                   "weewx\.drivers\.wmr300: ield delayed for",
                   "weewx\.drivers\.wmr300: history buffer at",
                   "weewx\.drivers\.wmr300: History read nearly complete:",
                   "weewx\.drivers\.wmr300: USB Read delayed for",
                   "weewx\.drivers\.wmr300: Loop data packets in heartbeat interval",
                   "weewx\.drivers\.wmr300: raw packet:",
                   "weewx\.drivers\.wmr300: rain=",
                   "weewx\.drivers\.wmr300: converted packet:",
                   "weewx\.drivers\.wmr300: write: ",
                   "weewx\.drivers\.wmr300: flush buffer",
                   "weewx\.drivers\.wmr300: flush: discarded \d+ bytes",
                   "weewx\.drivers\.wmr300: [^\t\n\r\f\v]+ counts; ",
                   "weewx\.drivers\.wmr300: Found station at bus=",
                   "weewx\.drivers\.wmr300: decode: ",
                   "weewx\.drivers\.wmr300: history index: ",
                   "weewx\.drivers\.ws1: driver version is",
                   "weewx\.drivers\.ws1: using [a-z]{5} port",
                   "weewx\.drivers\.ws1: open serial port",
                   "weewx\.drivers\.ws1: close serial port",
                   "weewx\.drivers\.ws1: bytes: '",
                   "weewx\.drivers\.ws1: Connecting to",
                   "weewx\.drivers\.ws1: Will retry in",
                   "weewx\.drivers\.ws1: Closing connection to",
                   "weewx\.drivers\.ws1: Attempting to find record start",
                   "weewx\.drivers\.ws1: \(searching...\) buf:",
                   "weewx\.drivers\.ws1: Record start found!",
                   "weewx\.drivers\.ws1: \(found!\) buf:",
                   "weewx\.drivers\.ws1: buf is CRLF",
                   "weewx\.drivers\.ws1: buf has \d+ exclamation points.",
                   "weewx\.drivers\.ws1: buf: ",
                   "weewx\.drivers\.ws23xx: driver version is",
                   "weewx\.drivers\.ws23xx: serial port is",
                   "weewx\.drivers\.ws23xx: polling interval is",
                   "weewx\.drivers\.ws23xx: using \d+ second polling interval for",
                   "weewx\.drivers\.ws23xx: Waiting \d+ seconds before retry",
                   "weewx\.drivers\.ws23xx: create LinuxSerialPort",
                   "weewx\.drivers\.ws23xx: create Ws2300",
                   "weewx\.drivers\.ws23xx: station enter",
                   "weewx\.drivers\.ws23xx: station exit",
                   "weewx\.drivers\.ws23xx: close LinuxSerialPort",
                   "weewx\.drivers\.ws23xx: setting station clock to",
                   "weewx\.drivers\.ws23xx: station clock is",
                   "weewx\.drivers\.ws23xx: station archive interval is \d+ minutes",
                   "weewx\.drivers\.ws23xx: clearing console memory",
                   "weewx\.drivers\.ws23xx: record count is",
                   "weewx\.drivers\.ws23xx: gen_records: since_ts=",
                   "weewx\.drivers\.ws23xx: using (computer|station) clock with latest_ts",
                   "weewx\.drivers\.ws23xx: count is \d+ to satisfy timestamp",
                   "weewx\.drivers\.ws23xx: downloading \d+ records from station",
                   "weewx\.drivers\.ws28xx: frame length is",
                   "weewx\.drivers\.ws28xx: driver version is",
                   "weewx\.drivers\.ws28xx: frequency is",
                   "weewx\.drivers\.ws28xx: no new weather data",
                   "weewx\.drivers\.ws28xx: Scanning historical records",
                   "weewx\.drivers\.ws28xx: No historical data after",
                   "weewx\.drivers\.ws28xx: Scanned ",
                   "weewx\.drivers\.ws28xx: Found \d+ historical records",
                   "weewx\.drivers\.ws28xx: get station configuration",
                   "weewx\.drivers\.ws28xx: _WeatherState=",
                   "weewx\.drivers\.ws28xx: _TempIndoor=",
                   "weewx\.drivers\.ws28xx: _HumidityIndoor=",
                   "weewx\.drivers\.ws28xx: _TempOutdoor=",
                   "weewx\.drivers\.ws28xx: _HumidityOutdoor=",
                   "weewx\.drivers\.ws28xx: _Windchill=",
                   "weewx\.drivers\.ws28xx: _Dewpoint=",
                   "weewx\.drivers\.ws28xx: _WindSpeed=",
                   "weewx\.drivers\.ws28xx: _Gust=",
                   "weewx\.drivers\.ws28xx: _WindDirection=",
                   "weewx\.drivers\.ws28xx: _WindDirection1=",
                   "weewx\.drivers\.ws28xx: _WindDirection2=",
                   "weewx\.drivers\.ws28xx: _WindDirection3=",
                   "weewx\.drivers\.ws28xx: _WindDirection4=",
                   "weewx\.drivers\.ws28xx: _WindDirection=5",
                   "weewx\.drivers\.ws28xx: _RainLastMonth=",
                   "weewx\.drivers\.ws28xx: _RainLastWeek=",
                   "weewx\.drivers\.ws28xx: _Rain24H=",
                   "weewx\.drivers\.ws28xx: _Rain1H=",
                   "weewx\.drivers\.ws28xx: _RainTotal=",
                   "weewx\.drivers\.ws28xx: PressureRel_hPa=",
                   "weewx\.drivers\.ws28xx: PressureRel_inHg=",
                   "weewx\.drivers\.ws28xx: setResetMinMaxFlags:",
                   "weewx\.drivers\.ws28xx: testConfigChanged: checksum not changed:",
                   "weewx\.drivers\.ws28xx: testConfigChanged: checksum or resetMinMaxFlags changed:",
                   "weewx\.drivers\.ws28xx: OutBufCS=",
                   "weewx\.drivers\.ws28xx: InBufCS=",
                   "weewx\.drivers\.ws28xx: ClockMode=",
                   "weewx\.drivers\.ws28xx: TemperatureFormat=",
                   "weewx\.drivers\.ws28xx: PressureFormat=",
                   "weewx\.drivers\.ws28xx: RainFormat=",
                   "weewx\.drivers\.ws28xx: WindspeedFormat=",
                   "weewx\.drivers\.ws28xx: WeatherThreshold=",
                   "weewx\.drivers\.ws28xx: StormThreshold=",
                   "weewx\.drivers\.ws28xx: LCDContrast=",
                   "weewx\.drivers\.ws28xx: LowBatFlags=",
                   "weewx\.drivers\.ws28xx: WindDirAlarmFlags=",
                   "weewx\.drivers\.ws28xx: OtherAlarmFlags=",
                   "weewx\.drivers\.ws28xx: HistoryInterval=",
                   "weewx\.drivers\.ws28xx: TempIndoor_Min=",
                   "weewx\.drivers\.ws28xx: TempIndoor_Max=",
                   "weewx\.drivers\.ws28xx: TempOutdoor_Min=",
                   "weewx\.drivers\.ws28xx: TempOutdoor_Max=",
                   "weewx\.drivers\.ws28xx: HumidityIndoor_Min=",
                   "weewx\.drivers\.ws28xx: HumidityIndoor_Max=",
                   "weewx\.drivers\.ws28xx: HumidityOutdoor_Min=",
                   "weewx\.drivers\.ws28xx: HumidityOutdoor_Max=",
                   "weewx\.drivers\.ws28xx: Rain24HMax=",
                   "weewx\.drivers\.ws28xx: GustMax=",
                   "weewx\.drivers\.ws28xx: PressureRel_hPa_Min=",
                   "weewx\.drivers\.ws28xx: PressureRel_inHg_Min=",
                   "weewx\.drivers\.ws28xx: PressureRel_hPa_Max=",
                   "weewx\.drivers\.ws28xx: PressureRel_inHg_Max=",
                   "weewx\.drivers\.ws28xx: ResetMinMaxFlags=",
                   "weewx\.drivers\.ws28xx: Time",
                   "weewx\.drivers\.ws28xx: TempIndoor=",
                   "weewx\.drivers\.ws28xx: HumidityIndoor=",
                   "weewx\.drivers\.ws28xx: TempOutdoor=",
                   "weewx\.drivers\.ws28xx: HumidityOutdoor=",
                   "weewx\.drivers\.ws28xx: PressureRelative=",
                   "weewx\.drivers\.ws28xx: RainCounterRaw=",
                   "weewx\.drivers\.ws28xx: WindSpeed=",
                   "weewx\.drivers\.ws28xx: WindDirection=",
                   "weewx\.drivers\.ws28xx: Gust=",
                   "weewx\.drivers\.ws28xx: GustDirection=",
                   "weewx\.drivers\.ws28xx: setFrequency:",
                   "weewx\.drivers\.ws28xx: setDeviceID:",
                   "weewx\.drivers\.ws28xx: console is paired to device with ID",
                   "weewx\.drivers\.ws28xx: setLastStatCache: seen=",
                   "weewx\.drivers\.ws28xx: setCommModeInterval to",
                   "weewx\.drivers\.ws28xx: setTransceiverSerialNumber to",
                   "weewx\.drivers\.ws28xx: found transceiver at bus=",
                   "weewx\.drivers\.ws28xx: skipping transceiver with serial",
                   "weewx\.drivers\.ws28xx: manufacturer:",
                   "weewx\.drivers\.ws28xx: product:",
                   "weewx\.drivers\.ws28xx: interface:",
                   "weewx\.drivers\.ws28xx: claiming USB interface",
                   "weewx\.drivers\.ws28xx: releasing USB interface",
                   "weewx\.drivers\.ws28xx: CCommunicationService.init",
                   "weewx\.drivers\.ws28xx: buildFirstConfigFrame: cs=",
                   "weewx\.drivers\.ws28xx: buildConfigFrame",
                   "weewx\.drivers\.ws28xx: buildTimeFrame: cs=",
                   "weewx\.drivers\.ws28xx: buildACKFrame: action=",
                   "weewx\.drivers\.ws28xx: buildACKFrame: morphing action from",
                   "weewx\.drivers\.ws28xx: buildACKFrame: idx:",
                   "weewx\.drivers\.ws28xx: handleWsAck",
                   "weewx\.drivers\.ws28xx: handleConfig:",
                   "weewx\.drivers\.ws28xx: handleCurrentData:",
                   "weewx\.drivers\.ws28xx: handleHistoryData:",
                   "weewx\.drivers\.ws28xx: handleHistoryData: time=",
                   "weewx\.drivers\.ws28xx: handleHistoryData: request",
                   "weewx\.drivers\.ws28xx: handleHistoryData: start_index=",
                   "weewx\.drivers\.ws28xx: handleHistoryData: remove previous record",
                   "weewx\.drivers\.ws28xx: handleHistoryData: appending history record",
                   "weewx\.drivers\.ws28xx: handleHistoryData: skip record:",
                   "weewx\.drivers\.ws28xx: handleHistoryData: next=",
                   "weewx\.drivers\.ws28xx: handleNextAction: a1 \(first-time config\)",
                   "weewx\.drivers\.ws28xx: handleNextAction: a2 \(set config data\)",
                   "weewx\.drivers\.ws28xx: handleNextAction: a3 \(set time data\)",
                   "weewx\.drivers\.ws28xx: Time:",
                   "weewx\.drivers\.ws28xx: Skip settime; time difference",
                   "weewx\.drivers\.ws28xx: handleNextAction:",
                   "weewx\.drivers\.ws28xx: generateResponse:",
                   "weewx\.drivers\.ws28xx: initTransceiver: frequency_standard",
                   "weewx\.drivers\.ws28xx: base frequency:",
                   "weewx\.drivers\.ws28xx: frequency correction:",
                   "weewx\.drivers\.ws28xx: frequency registers:",
                   "weewx\.drivers\.ws28xx: transceiver identifier:",
                   "weewx\.drivers\.ws28xx: transceiver serial:",
                   "weewx\.drivers\.ws28xx: startRFThread: spawning RF thread",
                   "weewx\.drivers\.ws28xx: stopRFThread: waiting for RF thread to terminate",
                   "weewx\.drivers\.ws28xx: setting up rf communication",
                   "weewx\.drivers\.ws28xx: starting rf communication",
                   "weewx\.drivers\.ws28xx: stopping rf communication",
                   "weewx\.drivers\.ws28xx: SetTime/SetConfig data written"
                   ],
        'increment': {
            'startups': "__main__: Starting up weewx version",
            'hup_restarts': "__main__: Received signal HUP",
            'sigterm_shutdowns': "__main__: Received signal TERM \(15\)",
            'kbd_interrupts': "engine: Keyboard interrupt",
            'restarts': "engine: retrying",
            'archive_records_added': "weewx\.manager: Added record [a-zA-Z0-9() :-]+ to database",
            'summary_records_added': "weewx\.manager: Added record [a-zA-Z0-9() :-]+ to daily summary",
            'ftp_uploads': "ftpupload: Uploaded file",
            'ftp_fails': "ftpupload: Failed to upload file",
            'rsync_fails': "weeutil\.rsyncupload: .+ reported errors:",
        },
        'sum': {
            'cheetah_generated': "weewx\.cheetahgenerator: Generated (\d+) files for report",
            'images_generated': "weewx\.imagegenerator: Generated (\d+) images for",
            'files_copied': "weewx\.reportengine: Copied (\d+) files",
            'garbage': "weewx\.engine: Garbage collected (\d+) objects",
            'rsync_uploads': "rsync\'d (\d+) files"
        },
        'itemised': {
            'ftp': {
                'ftp': "ftpgenerator: Ftp'd (\d+) files in (\d+) seconds",
                'errors': {
                    'ftps_not_supported': "Your version of Python does not support FTPS. Using insecure connection.",
                    'ftp_connect_fail_attempt': "Unable to connect or log into server",
                    'ftp_connect_fail': "Attempted \d+ times to connect to server",
                    'ftp_upload_fail_attempt': "Attempt \#\d+. Failed uploading",
                    'ftp_make_dir_error': "Got error while attempting to make remote directory",
                    'ftp_error': "weeutil\.ftpupload:     \*\*\*\*  Error:",
                    'ftp_make_dir_fail': "Unable to create remote directory"
                }
            },
            'rsync': {
                'errors': {
                    'rsync_not_installed': "rsync does not appear to be installed on",
                    'rsync_errors': "weeutil\.rsyncupload .+ reported errors:"
                }
            },
            'restx': {
                'restx_published': "weewx\.restx: ([^:]*): Published record",
                'restx_skipped': "weewx\.restx: ([^:]*): Skipped record",
                'errors': {
                    'restx_shut_thread_fail': "weewx\.restx: Unable to shut down .+ thread",
                    'restx_db_error': "weewx\.restx: .+: Database OperationalError",
                    'restx_bad_login_wait': "weewx\.restx: .+: Bad login; waiting",
                    'restx_bad_login_terminate': "weewx\.restx: .+: Bad login; no retry specified. Terminating",
                    'restx_upload_errors': "weewx\.restx: ([^:]*): Failed to publish",
                    'restx_bad_cert_wait': "weewx\.restx: .+: Bad SSL certificate \(",
                    'restx_bad_cert_terminate': "weewx\.restx: .+: Bad SSL certificate; no retry specified. Terminating",
                    'restx_unexpect_exception': "weewx\.restx: .+: Unexpected exception of type",
                    'restx_thread_terminate': "weewx\.restx: .+: Thread terminating. Reason:",
                    'restx_upload_attempt_fail': "weewx\.restx: .+: Failed upload attempt",
                    'restx_bad_server': "weewx\.restx: .+: Bad server address:",
                    'restx_connection_error_attempt': "weewx\.restx: .+: Attempt \d+ to .+:\d+. Connection error:",
                    'restx_socket_error_attempt': "weewx\.restx: .+: Attempt \d+ to .+:\d+. Socket send error:",
                    'restx_response_exception': "weewx\.restx: .+: Exception .+ when looking for response to",
                    'restx_missing_config': "weewx\.restx: .+: No config info. Skipped.",
                    'restx_missing_option': "weewx\.restx: .+: Data will not be posted: Missing option"
                },
            },
            'image_generator': {
                'errors': {
                    'image_gen_agg_errors': "weewx\.imagegenerator: aggregate interval required for aggregate type|weewx\.imagegenerator: line type \S+ skipped"
                }
            },
            'vantage': {
                 'vantage_wakeup_fail': "ERROR weewx\.drivers\.vantage: Unable to wake up console",
                 'vantage_no_ack': "weewx\.drivers\.vantage: No <ACK> received from console",
                 'vantage_send_crc_fail': "weewx\.drivers\.vantage: Unable to pass CRC16 check while sending data",
                 'vantage_send_cmd_max_retries': "weewx\.drivers\.vantage: Max retries exceeded while sending command",
                 'vantage_get_crc_fail': "weewx\.drivers\.vantage: Unable to pass CRC16 check while getting data",
                 'vantage_crc_timeout': "weewx\.drivers\.vantage: Timeout in get_data_with_crc16",
                 'vantage_loop_max_tries_error': "weewx\.drivers\.vantage: LOOP max tries \(\d+\) exceeded",
                 'vantage_dmpaft_max_ties': "weewx\.drivers\.vantage: DMPAFT max tries \(\d+\) exceeded",
                 'vantage_get_time_max_tries': "weewx\.drivers\.vantage: Max retries exceeded while getting time",
                 'vantage_clock_set': "weewx\.drivers.vantage: Clock set to",
                 'vantage_set_time_max_tries': "weewx\.drivers\.vantage: Max retries exceeded while setting time",
                 'vantage_cup_set': "weewx\.drivers\.vantage: Wind cup type set to",
                 'vantage_bucket_set': "weewx\.drivers\.vantage: Rain bucket type set to",
                 'vantage_rain_year_set': "weewx\.drivers\.vantage: Rain year start set to",
                 'vantage_barometer_cal_set': "weewx\.drivers\.vantage: Set barometer calibration",
                 'vantage_lat_set': "weewx\.drivers\.vantage: Station latitude set to",
                 'vantage_long_set': "weewx\.drivers\.vantage: Station longitude set to",
                 'vantage_interval_set': "weewx\.drivers\.vantage: Archive interval set to",
                 'vantage_lamp_set': "weewx\.drivers\.vantage: Lamp set to",
                 'vantage_trans_type_set': "weewx\.drivers\.vantage: Transmitter type for channel",
                 'vantage_retrans_set': "weewx\.drivers\.vantage: Retransmit set to",
                 'vantage_console_temp_log_set': "weewx\.drivers\.vantage: Console temperature logging set to",
                 'vantage_wind_cal_set': "weewx\.drivers\.vantage: Wind calibration set to",
                 'vantage_temp_cal_set': "weewx\.drivers\.vantage: Temperature calibration",
                 'vantage_hum_cal_set': "weewx\.drivers\.vantage: Humidity calibration",
                 'vantage_archive_mem_clear': "weewx\.drivers\.vantage: Archive memory cleared",
                 'vantage_clear_log_max_tries': "weewx\.drivers\.vantage: Max retries exceeded while clearing log",
                 'vantage_inconsist_eeprom': "weewx\.drivers\.vantage: Inconsistent EEPROM calibration values",
                 'vantage_hardware_type_no_read': "weewx\.drivers\.vantage: Unable to read hardware type",
                 'vantage_eeprom_max_tries': "weewx\.drivers\.vantage: Max retries exceeded while getting EEPROM data at address",
                 'errors': {
                     'vantage_wakeup_retry_fail': "weewx\.drivers\.vantage: Retry #\d+ failed",
                     'vantage_send_crc_try': "weewx\.drivers\.vantage: send_data_with_crc16; try #\d+",
                     'vantage_send_cmd_try': "weewx\.drivers\.vantage: send_command; try #\d+ failed",
                     'vantage_get_crc_try': "weewx\.drivers\.vantage: Get_data_with_crc16; try #\d+ failed",
                     'vantage_serial_exception_read': "weewx\.drivers\.vantage: SerialException on read",
                     'vantage_serial_exception_write': "weewx\.drivers\.vantage: SerialException on write",
                     'vantage_socket_error': "weewx\.drivers\.vantage: Socket error while opening port",
                     'vantage_eth_no_conn': "weewx\.drivers\.vantage: Unable to connect to ethernet host",
                     'vantage_ip_read_error': "weewx\.drivers\.vantage: ip-read error",
                     'vantage_ip_write_error': "weewx\.drivers\.vantage: ip-write error",
                     'vantage_loop_try_error': "weewx\.drivers\.vantage: LOOP try #\d+; error",
                     'vantage_dmpaft_try_error': "weewx\.drivers\.vantage: DMPAFT try #\d+; error",
                     'vantage_determine_hardware_retry': "weewx\.drivers\.vantage: _determine_hardware; retry",
                     'vantage_unknown_bucket': "weewx\.drivers\.vantage: Unknown bucket type",
                     'vantage_unknown_loop': "weewx\.drivers\.vantage: Unknown LOOP packet type"
                }               
            },
            'fousb': {
                'fousb_read_block_change': "weewx\.drivers\.fousb: read_block change",
                'fousb_rain_count_dec': "weewx\.drivers\.fousb: ignoring spurious rain counter decrement",
                'fousb_rain_count_wrap': "weewx\.drivers\.fousb: rain counter wraparound detected",
                'fousb_power_cycles_attempted': "weewx\.drivers\.fousb: Attempting to power cycle",
                'fousb_power_cycles_completed': "weewx\.drivers\.fousb: Power cycle complete",
                'fousb_sync_to_station': "weewx\.drivers\.fousb: synchronised to",
                'fousb_unex_sensor_clk_change': "weewx\.drivers\.fousb: unexpected sensor clock change",
                'fousb_setting_sensor_clk': "weewx\.drivers\.fousb: setting sensor clock",
                'fousb_lost_sync': "weewx\.drivers\.fousb: lost sync",
                'fousb_missed_interval': "weewx\.drivers\.fousb: missed interval",
                'fousb_unexpected_clock_change': "weewx\.drivers\.fousb: unexpected station clock change",
                'fousb_setting_stn_clk': "weewx\.drivers\.fousb: setting station clock ",
                'fousb_lost_log_sync': "weewx\.drivers\.fousb: lost log sync",
                'errors': {
                    'fousb_get_interval_fail': "weewx\.drivers\.fousb: Get archive interval failed attempt %d+",
                    'fousb_cannot_find_device': "weewx\.drivers\.fousb: Cannot find USB device with Vendor=",
                    'fousb_cannot_claim_usb': "weewx\.drivers\.fousb: Unable to claim USB interface",
                    'fousb_station_status': "weewx\.drivers\.fousb: station status ",
                    'fousb_get_obs_fail': "weewx\.drivers\.fousb: get_observations failed:",
                    'fousb_invalid_data': "weewx\.drivers\.fousb: invalid data in get_records at",
                    'fousb_get_rec_fail': "weewx\.drivers\.fousb: get_records failed:",
                    'fousb_invalid_data_while_sync': "weewx\.drivers\.fousb: invalid data while synchronising at",
                    'fousb_unex_ptr_change': "weewx\.drivers\.fousb: unexpected ptr change",
                    'fousb_changing_format': "weewx\.drivers\.fousb: changing data format from",
                    'fousb_unstable_read': "weewx\.drivers\.fousb: unstable read: blocks differ for ptr",
                    'fousb_unrecog_magic_number': "weewx\.drivers\.fousb: unrecognised magic number",
                    'fousb_magic_num_changed': "weewx\.drivers\.fousb: magic number changed"
                }
            },
            'acurite': {
                'acurite_loop_max_tries_error': "weewx\.drivers\.acurite: Max retries \(\d+\) exceeded for LOOP data",
                'acurite_rain_count_dec': "weewx\.drivers\.acurite: rain counter decrement ignored:",
                'errors': {
                    'acurite_fail_loop_attempt': "weewx\.drivers\.acurite: Failed attempt \d+ of %d+ to get LOOP data:",
                    'acurite_r3_read_fail': "weewx\.drivers\.acurite: R3: read failed \d+",
                    'acurite_r3_usb_mode_3': "weewx\.drivers\.acurite: R3: put station in USB mode 3 to enable R3 data",
                    'acurite_cannot_find_device': "weewx\.drivers\.acurite: Cannot find USB device with VendorID=",
                    'acurite_cannot_claim_usb': "weewx\.drivers\.acurite: Unable to claim USB interface",
                    'acurite_iface_release_fail': "weewx\.drivers\.acurite: release interface failed",
                    'acurite_r1_stale_data': "weewx\.drivers\.acurite: R1: ignoring stale data (rssi indicates no communication from sensors):",
                    'acurite_r1_bad_length': "weewx\.drivers\.acurite: R1: bad length:",
                    'acurite_r1_bad_format': "weewx\.drivers\.acurite: R1: bad format:",
                    'acurite_r1_no_sensors': "weewx\.drivers\.acurite: R1: no sensors found:",
                    'acurite_r1_bogus_flavor': "weewx\.drivers\.acurite: R1: bogus message flavor",
                    'acurite_r1_bogus_final_byte': "weewx\.drivers\.acurite: R1: bogus final byte",
                    'acurite_r2_bad_length': "weewx\.drivers\.acurite: R2: bad length:",
                    'acurite_r2_bad_format': "weewx\.drivers\.acurite: R2: bad format:",
                    'acurite_r3_bad_value': "weewx\.drivers\.acurite: R3: bad value in row",
                    'acurite_r3_bad_length': "weewx\.drivers\.acurite: R3: bad length in row",
                    'acurite_r3_bad_format': "weewx\.drivers\.acurite: R3: bad format in row",
                    'acurite_r2_unkown_cal': "weewx\.drivers\.acurite: R2: unknown calibration constants:",
                    'acurite_r2_const_changed': "weewx\.drivers\.acurite: R2: constants changed: old:"
                }
            },
            'cc3000': {
                'cc3000_max_retries': "weewx\.drivers\.cc3000: Max retries (%d) exceeded",
                'cc3000_gettime_fail': "weewx\.drivers\.cc3000: getTime failed:",
                'cc3000_init_fail_attempt': "weewx\.drivers\.cc3000: Failed attempt \d+ of \d+ to initialize station:",
                'cc3000_val_hdr_mismatch': "weewx\.drivers\.cc3000: Values/header mismatch:",
                'cc3000_parse_fail': "weewx\.drivers\.cc3000: Parse failed for",
                'cc3000_echo_timeout': "weewx\.drivers\.cc3000: \S+: Reading cmd echo timed out",
                'cc3000_no_sensor_data': "weewx\.drivers\.cc3000: No data from sensors",
                'cc3000_set_time': "weewx\.drivers\.cc3000: Set time to",
                'cc3000_set_dst': "weewx\.drivers\.cc3000: Set DST to",
                'cc3000_set_units': "weewx\.drivers\.cc3000: Set units to",
                'cc3000_set_log_interval': "weewx\.drivers\.cc3000: Set logging interval to",
                'cc3000_set_channel': "weewx\.drivers\.cc3000: Set channel to",
                'cc3000_set_baro_offset': "weewx\.drivers\.cc3000: Set barometer offset to",
                'cc3000_reset_max': "weewx\.drivers\.cc3000: Reset max values",
                'cc3000_reset_min': "weewx\.drivers\.cc3000: Reset min values",
                'cc3000_mem_clear': "weewx\.drivers\.cc3000: MEM=CLEAR succeeded.",
                'cc3000_reset_rain': "weewx\.drivers\.cc3000: Reset rain counter",
                'errors': {
                    'cc3000_mem_usage_fail': "weewx\.drivers\.cc3000: Memory check: Cannot determine memory usage",
                    'cc3000_get_data_fail_attempt': "weewx\.drivers\.cc3000: Failed attempt \d+ of \d+ to get data:",
                    'cc3000_retry_worked': "weewx\.drivers\.cc3000: \S+: Retry worked.  Total tries:",
                    'cc3000_retry_fail': "weewx\.drivers\.cc3000: \S+: Retry failed.",
                    'cc3000_unexpected_rec': "weewx\.drivers\.cc3000: Unexpected record"
                }
            },
            'te923': {
                'errors': {
                    'te923_skip_dupe_ts': "weewx\.drivers\.te923: skip packet with duplidate timestamp",
                    'te923_cannot_find_device': "weewx\.drivers\.te923: Cannot find USB device with VendorID=",
                    'te923_cannot_claim_usb': "weewx\.drivers\.te923: Unable to claim USB interface",
                    'te923_rel_iface_fail': "weewx\.drivers\.te923: release interface failed:",
                    'te923_read_timeout': "weewx\.drivers\.te923: timeout while reading: ignoring bytes:",
                    'te923_wrong_num_bytes': "weewx\.drivers\.te923: read: wrong number of bytes:",
                    'te923_write_wrong_bytes': "weewx\.drivers\.te923: write: ack got wrong number of bytes:",
                    'te923_read_data_fail': "weewx\.drivers\.te923: Failed attempt \d+ of \d+ to read data:",
                    'te923_write_data_fail': "weewx\.drivers\.te923: Failed attempt \d+ of \d+ to write data:",
                    'te923_unrecog_mem_size': "weewx\.drivers\.te923: Unrecognised memory size",
                    'te923_rec_index_exceeds_mem': "weewx\.drivers\.te923: record index of \d+ exceeds memory size of",
                    'te923_too_many_rec': "weewx\.drivers\.te923: too many records requested \(\d+\), using",
                    'te923_gen_rec_skip': "weewx\.drivers\.te923: gen_records: skip",
                    'te923_no_data_at_add': "weewx\.drivers\.te923: get_record: no data at address",
                    'te923_unrecog_interval': "weewx\.drivers\.te923: Unrecognized archive interval"
                }
            },
            'ultimeter': {
                'ultimeter_set_time': "weewx\.drivers\.ultimeter: Set station time to",
                'ultimeter_set_year': "weewx\.drivers\.ultimeter: Set station year to",
                'ultimeter_set_logger_mode': "weewx\.drivers\.ultimeter: Set station to logger mode",
                'ultimeter_set_modem_mode': "weewx\.drivers\.ultimeter: Set station to modem mode",
                'ultimeter_readings_max_retries': "weewx\.drivers\.ultimeter: Max retries \(\d+\) exceeded for readings",
                'errors': {
                    'ultimeter_get_time_fail': "weewx\.drivers\.ultimeter: get_time failed:",
                    'ultimeter_get_readings_fail': "weewx\.drivers\.ultimeter: Failed attempt \d+ of \d+ to get readings:",
                    'ultimeter_decode_fail': "weewx\.drivers\.ultimeter: Decode failed for"
                }
            },
            'wmr9x8': {
                'wmr9x8_rx_wm918_data_packet': "weewx\.drivers\.wmr9x8: Received WM-918 data packet",
                'errors': {
                    'wmr9x8_invalid_packet': "weewx\.drivers\.wmr9x8: Invalid data packet"
                }
            },
            'wmr100': {
                'wmr100_usb_report_max_retries': "weewx\.drivers\.wmr100: Max retries exceeded while fetching USB reports",
                'errors': {
                    'wmr100_cannot_claim_usb': "weewx\.drivers\.wmr100: Unable to claim USB interface:",
                    'wmr100_cannot_find_device': "weewx\.drivers\.wmr100: Unable to find USB device",
                    'wmr100_malformed_packet': "weewx\.drivers\.wmr100: Malformed packet:",
                    'wmr100_checksum_exception': "weewx\.drivers\.wmr100: Exception while calculating checksum:",
                    'wmr100_buffer_length_bad checksum': "weewx\.drivers\.wmr100: Bad checksum on buffer of length",
                    'wmr100_unable_send_usb_ctl': "weewx\.drivers\.wmr100: Unable to send USB control message:",
                    'wmr100_bad_usb_report': "weewx\.drivers\.wmr100: Bad USB report received:"
                }
            },
            'wmr200': {
                'wmr200_': "weewx\.drivers\.wmr200: No USB handle for usb_device Write",
                'wmr200_size_fail': "weewx\.drivers\.wmr200: Failed to extract size from packet",
                'wmr200_timestamp_not_set': "weewx\.drivers\.wmr200: timestamp_record() Timestamp not set in record",
                'wmr200_cooked_before_setup': "weewx\.drivers\.wmr200: print_cooked() called before proper setup",
                'wmr200_invalid_time_drift': "weewx\.drivers\.wmr200: timestamp_adjust_drift() called with invalid time drift",
                'wmr200_out_temp_fault': "weewx\.drivers\.wmr200: Temp outdoor sensor fault",
                'wmr200_wind_fault': "weewx\.drivers\.wmr200: Wind sensor fault",
                'wmr200_uv_fault': "weewx\.drivers\.wmr200: UV Sensor fault",
                'wmr200_rain_fault': "weewx\.drivers\.wmr200: Rain sensor fault",
                'wmr200_clock_unsync': "weewx\.drivers\.wmr200: Clock time unsynchronized",
                'wmr200_out_temp_batt': "weewx\.drivers\.wmr200: Temp outdoor sensor: Battery low",
                'wmr200_wind_batt': "weewx\.drivers\.wmr200: Wind sensor: Battery low",
                'wmr200_uv_batt': "weewx\.drivers\.wmr200: UV sensor: Battery low",
                'wmr200_rain_batt': "weewx\.drivers\.wmr200: Rain sensor: Battery low",
                'wmr200_device_unreponsive': "weewx\.drivers\.wmr200: Device unresponsive after multiple resets",
                'wmr200_usb_read_error': "weewx\.drivers\.wmr200: USB device read error",
                'wmr200_reset_console': "weewx\.drivers\.wmr200: Reset console device",
                'wmr200_cannot_find_device': "weewx\.drivers\.wmr200: Unable to find device with VendorID=",
                'wmr200_usb_poll_thread_term': "weewx\.drivers\.wmr200: USB polling thread unexpectedly terminated",
                'wmr200_packet_count': "weewx\.drivers\.wmr200: Received packet count live:(\d+) archive:(\d+) control:(\d+)",
                'wmr200_bytes': "weewx\.drivers\.wmr200: Received bytes:(\d+) sent bytes:(\d+)",
                'wmr200_bogus_packet': "weewx\.drivers\.wmr200: Discarding bogus packet:",
                'wmr200_no_live_packet': "weewx\.drivers\.wmr200: genArchive() Unable to process archive packets until live packet received",
                'wmr200_ignore_rec': "weewx\.drivers\.wmr200: genArchive() Ignoring received archive record before requested timestamp",
                'wmr200_out_of_order_rec': "weewx\.drivers\.wmr200: genStartup() Discarding received archive record that presented out-of-order;",
                'wmr200_archive_int_exceed': "weewx\.drivers\.wmr200: genStartup() Discarding received archive record exceeding archive interval cnt:",
                'wmr200_interval_zero': "weewx\.drivers\.wmr200: genStartup() Discarding received archive record since interval is zero",
                'wmr200_rec_before_time': "weewx\.drivers\.wmr200: genStartup() Discarding received archive record before time requested cnt:",
                'errors': {
                    'wmr200_packet_to_small': "weewx\.drivers\.wmr200: Packet too small to compute 16 bit checksum",
                    'wmr200_': "weewx\.drivers\.wmr200: Packet too small to contain 16 bit checksum",
                    'wmr200_cannot_get_timestamp': "weewx\.drivers\.wmr200: Packet length too short to get timestamp len",
                    'wmr200_index_decode_index_fail': "weewx\.drivers\.wmr200: [^\t\n\r\f\v]+ index decode index failure",
                    'wmr200_index_decode_fail': "weewx\.drivers\.wmr200: [^\t\n\r\f\v]+ decode index failure",
                    'wmr200_cannot_open_usb': "weewx\.drivers\.wmr200: open_device() Unable to open USB interface. Reason:",
                    'wmr200_device_not_spec': "weewx\.drivers\.wmr200: open_device() Device not specified.",
                    'wmr200_cannot_claim_usb': "weewx\.drivers\.wmr200: open_device() Unable to claim USB interface.",
                    'wmr200_cannot_release_iface': "weewx\.drivers\.wmr200: close_device() Unable to release device interface",
                    'wmr200_no_usb_handle': "weewx\.drivers\.wmr200: read_device() No USB handle for usb_device Read",
                    'wmr200_usb_overflow': "weewx\.drivers\.wmr200: USB read_device overflow error",
                    'wmr200_index_range_fail': "weewx\.drivers\.wmr200: read_device() Failed the index rage",
                    'wmr200_usb_read_error': "weewx\.drivers\.wmr200: read_device() USB Error",
                    'wmr200_no_data': "weewx\.drivers\.wmr200: No data received in \d+ seconds",
                    'wmr200_write_cannot_send_usb_control': "weewx\.drivers\.wmr200: write_device() Unable to send USB control message",
                    'wmr200_unexpected_packet_size': "weewx\.drivers\.wmr200: Unexpected packet size act:",
                    'wmr200_no_get_key': "weewx\.drivers\.wmr200: Record get key not found in record key:",
                    'wmr200_no_set_key': "weewx\.drivers\.wmr200: Record set key not found in record key:",
                    'wmr200_record_update_fail': "weewx\.drivers\.wmr200: Record update failed to apply record:",
                    'wmr200_checksum_miscompare': "weewx\.drivers\.wmr200: Checksum miscompare act:",
                    'wmr200_pressure_unknown': "weewx\.drivers\.wmr200:   Pressure unknown nibble:",
                    'wmr200_reset_cannot_send_usb_control': "weewx\.drivers\.wmr200: reset_console() Unable to send USB control",
                    'wmr200_unverifeid_interval': "weewx\.drivers\.wmr200: Unverified archive interval:",
                    'wmr200_restart_count': "weewx\.drivers\.wmr200: Restart count:",
                    'wmr200_write_cannot_send_usb': "weewx\.drivers\.wmr200: _write_cmd() Unable to send USB cmd:",
                    'wmr200_usb_poll_thread_alive': "weewx\.drivers\.wmr200: USB polling thread still alive",
                    'wmr200_wdog_thread_alive': "weewx\.drivers\.wmr200: Watchdog thread still alive",
                    'wmr200_exit_archive_packets_queued': "weewx\.drivers\.wmr200: Exiting with packets still in archive queue cnt:",
                    'wmr200exit_live_packets_queued': "weewx\.drivers\.wmr200: Exiting with packets still in live queue cnt:"
                }
            },
            'wmr300': {
                'wmr300_history_fail': "weewx\.drivers\.wmr300: Finish history failed after \d+ tries",
                'wmr300_history_cleared': "weewx\.drivers\.wmr300: History clear completed in",
                'wmr300_rain_ctr_dec': "weewx\.drivers\.wmr300: rain counter decrement detected:",
                'wmr300_poss_missed_rain_event': "weewx\.drivers\.wmr300: possible missed rain event:",
                'errors': {
                    'wmr300_comm_attempt_fail': "weewx\.drivers\.wmr300: init_comm: failed attempt \d+ of \d+:",
                    'wmr300_init_history_attempt_fail': "weewx\.drivers\.wmr300: init_history: failed attempt \d+ of \d+:",
                    'wmr300_fin_history_attempt_fail': "weewx\.drivers\.wmr300: finish history failed attempt \d+ of \d+:",
                    'wmr300_history_index_not_set': "weewx\.drivers\.wmr300: read history skipped: index has not been set",
                    'wmr300_history_bad_index': "weewx\.drivers\.wmr300: read history failed: bad index:",
                    'wmr300_missing_rec': "weewx\.drivers\.wmr300: missing record: skipped from",
                    'wmr300_bogus_history_rec_index': "weewx\.drivers\.wmr300: Bogus historical record index:",
                    'wmr300_get_history': "weewx\.drivers\.wmr300: get_history:",
                    'wmr300_get_history_unex_packet': "get_history: unexpected packet, content:",
                    'wmr300_history_bogus_entries': "weewx\.drivers\.wmr300: During history read, \d+ bogus entries found from",
                    'wmr300_excess_hbeat_delay': "weewx\.drivers\.wmr300: Excessive heartbeat delay: \d+s, restarting",
                    'wmr300_no_loop_in_hbeat_interval': "weewx\.drivers\.wmr300: No loop data in heartbeat interval,  restarting",
                    'wmr300_genlooppackets': "weewx\.drivers\.wmr300: genLoopPackets: ",
                    'wmr300_rain_counter_at_max': "weewx\.drivers\.wmr300: rain counter at maximum, reset required",
                    'wmr300_rain_counter_warning': "weewx\.drivers\.wmr300: rain counter is above warning level, reset recommended",
                    'wmr300_bad_interval': "weewx\.drivers\.wmr300: ignoring record: bad interval",
                    'wmr300_rel_iface_fail': "weewx\.drivers\.wmr300: Release interface failed:",
                    'wmr300_read': "weewx\.drivers\.wmr300: read: "
                }
            },
            'ws1': {
                'ws1_readings_max_retries': "weewx\.drivers\.ws1: Max retries \(\d+\) exceeded for readings",
                'ws1_retry_conn': "weewx\.drivers\.ws1: Retrying connection...",
                'ws1_conn_max_retries': "weewx\.drivers\.ws1: Max tries (%d) exceeded for connection.",
                'errors': {
                    'ws1_decode_fail': "weewx\.drivers\.ws1: decode failed for",
                    'ws1_readings_attempt_fail': "weewx\.drivers\.ws1: Failed attempt \d+ of \d+ to get readings:",
                    'ws1_cannot_create_socket': "weewx\.drivers\.ws1: Cannot create socket for some reason:",
                    'ws1_cannot_conn': "weewx\.drivers\.ws1: Cannot connect to",
                    'ws1_cannot_close_conn': "weewx\.drivers\.ws1: Cannot close connection to",
                    'ws1_get_data_fail': "weewx\.drivers\.ws1: Failed to get data. Reason:"
                }
            },
            'ws23xx': {
                'ws23xx_conn_changed': "weewx\.drivers\.ws23xx: connection changed from",
                'ws23xx_exceed_loop_retries': "weewx\.drivers\.ws23xx: Max retries \(\d+\) exceeded for LOOP data",
                'ws23xx_set_hware_interval': "weewx\.drivers\.ws23xx: setting hardware archive interval to \d+ minutes",
                'errors': {
                    'ws23xx_loop_attempt_fail': "weewx\.drivers\.ws23xx: Failed attempt \d+ of \d+ to get LOOP data:",
                    'ws23xx_invalid_wind_speed': "weewx\.drivers\.ws23xx: invalid wind reading: speed="
                }
            },
            'ws28xx': {
                'ws28xx_cannot_find_device': "weewx\.drivers\.ws28xx: Cannot find USB device with Vendor=",
                'ws28xx_cannot_claim_usb': "weewx\.drivers\.ws28xx: Unable to claim USB interface",
                'ws28xx_adjusted_freq': "weewx\.drivers\.ws28xx: adjusted frequency:",
                'errors': {
                    'ws28xx_no_new_data': "weewx\.drivers\.ws28xx: no new weather data",
                    'ws28xx_no_contact': "weewx\.drivers\.ws28xx: no contact with console",
                    'ws28xx_no_data': "weewx\.drivers\.ws28xx: No data after \d+ seconds",
                    'ws28xx_unknown_freq': "weewx\.drivers\.ws28xx: unknown frequency",
                    'ws28xx_bogus_date': "weewx\.drivers\.ws28xx: ToDateTime: bogus date for",
                    'ws28xx_unknown_bytes': "weewx\.drivers\.ws28xx: Bytes with unknown meaning at",
                    'ws28xx_temp_unknown_fmt': "weewx\.drivers\.ws28xx: setTemps: unknown temperature format",
                    'ws28xx_temp_out_of_range': "weewx\.drivers\.ws28xx: setTemps: one or more values out of range",
                    'ws28xx_hum_out_of_range': "weewx\.drivers\.ws28xx: setHums: one or more values out of range",
                    'ws28xx_rain_unknown_fmt': "weewx\.drivers\.ws28xx: setRain24: unknown format",
                    'ws28xx_rain_out_of_range': "weewx\.drivers\.ws28xx: setRain24: value outside range",
                    'ws28xx_gust_unknown_fmt': "weewx\.drivers\.ws28xx: setGust: unknown format",
                    'ws28xx_gust_wrong_units': "weewx\.drivers\.ws28xx: setGust: only units of km/h are supported",
                    'ws28xx_gust_out_of_range': "weewx\.drivers\.ws28xx: setGust: value outside range",
                    'ws28xx_rel_press_unknown_fmt': "weewx\.drivers\.ws28xx: setPresRel: unknown format",
                    'ws28xx_rel_press_out_of_range': "weewx\.drivers\.ws28xx: setPresRel: value outside range",
                    'ws28xx_inbufcs_not_match': "weewx\.drivers\.ws28xx: handleCurrentData: inBufCS of station does not match",
                    'ws28xx_outbufcs_changed': "weewx\.drivers\.ws28xx: handleCurrentData: outBufCS of station changed",
                    'ws28xx_history_too_many_reqs': "weewx\.drivers\.ws28xx: handleHistoryData: too many records requested",
                    'ws28xx_history_index_mismatch': "weewx\.drivers\.ws28xx: handleHistoryData: index mismatch:",
                    'ws28xx_attempting_to_pair': "weewx\.drivers\.ws28xx: generateResponse: console not paired, attempting to pair to",
                    'ws28xx_unknown_device_id': "weewx\.drivers\.ws28xx: message from console contains unknown device ID",
                    'ws28xx_cannot_terminate_rf_thread': "weewx\.drivers\.ws28xx: unable to terminate RF thread after \d+ seconds",
                    'ws28xx_dorf_exception': "weewx\.drivers\.ws28xx: exception in doRF:",
                    'ws28xx_gen_response_fail': "weewx\.drivers\.ws28xx: generateResponse failed:"
                }
            },
            'maxwindspeed_fix': {
                'errors': {
                    'maxwindspeed_fix_fail': "weewx\.database: maxwindspeed: .+ not applied:"
                }
            },
            'interval_weighting_fix': {
                'errors': {
                    'db_interval_weight_fix_fail': "weewx\.database: intervalweighting: Interval weighting of .+ failed:"
                }
            }
        },
    },
    'report': {
        'summary': [
            {'startups': 'engine: startups'},
            {'restarts': 'engine: restarts'},
            {'hup_restarts': 'engine: restart from hup'},
            {'sigterm_shutdowns': 'engine: restart from SIGTERM'},
            {'kbd_interrupts': 'engine: keyboard interrupts'},
            {'garbage': 'engine: garbage collected'},
            {'archive_records_added': 'archive: records added'},
            {'summary_records_added': 'daily summaries: records added'},
            {'files_copied': 'copygenerator: files copied'},
            {'ftp_uploads': 'ftp: files uploaded'},
            {'ftp_fails': 'ftp: failures'},
            {'rsync_uploads': 'rsync: files uploaded'},
            {'rsync_fails': 'rsync: failures'},
            {'vantage_clock_set': 'vantage: times clock was set'}
        ],
        'itemised': [
            {
                'restx': {
                    'label': "RESTful services",
                    'items': [
                        {'restx_published': "Records published"},
                        {'restx_skipped': "Records skipped"}
                    ],
                    'errors': {
                        'label': "Errors",
                        'items': [
                            {'restx_upload_errors': "Failed to upload"},
                            {'restx_shut_thread_fail': "Unable to shutdown thread"},
                            {'restx_db_error': "Database operational error"},
                            {'restx_bad_login_wait': "Bad login (waiting)"},
                            {'restx_bad_login_terminate': "Bad login (no retry)"},
                            {'restx_bad_cert_wait': "Bad SSL certificate"},
                            {'restx_bad_cert_terminate': "Bad SSL certificate (no retry)"},
                            {'restx_unexpect_exception': "Unexpected exception"},
                            {'restx_thread_terminate': "Thread terminating"},
                            {'restx_upload_attempt_fail': "Failed upload attempt"},
                            {'restx_bad_server': "Bad server address:"},
                            {'restx_connection_error_attempt': "Connection error"},
                            {'restx_socket_error_attempt': "Socket send error"},
                            {'restx_response_exception': "Exception when looking for response"},
                            {'restx_no_station_url': "No station URL specified"},
                            {'restx_missing_config': "No config info"},
                            {'restx_missing_option': "Missing option"}
                        ]
                    }
                },
                'cheetah_generator': {
                    'label': "Cheetah generator",
                    'items': [
                        {'cheetah_generated': "Files generated"}
                    ]
                },
                'image_generator': {
                    'label': "Image generator",
                    'items': [
                        {'images_generated': "Images generated"}
                    ],
                    'errors': {
                        'label': "Errors",
                        'items': [
                            {'image_gen_agg_errors': "Aggregate interval missing"}
                        ]
                    }
                },
                'vantage': {
                    'label': "Vantage",
                    'items': [
                        {'vantage_wakeup_fail': "Failure to wake up console"},
                        {'vantage_no_ack': "No acknowledgement received from console"},
                        {'vantage_send_crc_fail': "Unable to pass CRC16 check while sending data"},
                        {'vantage_send_cmd_max_retries': "Max retries exceeded while sending command"},
                        {'vantage_get_crc_fail': "Unable to pass CRC16 check while getting data"},
                        {'vantage_crc_timeout': "Timeout in while getting data with CRC"},
                        {'vantage_loop_max_tries_error': "Max retries exceeed while reading Loop data"},
                        {'vantage_dmpaft_max_ties': "Max retries exceeded while reading DMPAFT data"},
                        {'vantage_get_time_max_tries': "Max retries exceeded while getting time"},
                        {'vantage_set_time': "Console time set"},
                        {'vantage_set_time_max_tries': "Max retries exceeded while setting time"},
                        {'vantage_cup_set': "Wind cup type set"},
                        {'vantage_bucket_set': "Rain bucket type set "},
                        {'vantage_rain_year_set': "Rain year start set"},
                        {'vantage_barometer_cal_set': "Barometer calibration set"},
                        {'vantage_lat_set': "Station latitude set"},
                        {'vantage_long_set': "Station longitude set"},
                        {'vantage_interval_set': "Archive interval set"},
                        {'vantage_lamp_set': "Lamp set"},
                        {'vantage_trans_type_set': "Transmitter type set for channel"},
                        {'vantage_retrans_set': "Retransmit set"},
                        {'vantage_console_temp_log_set': "Console temperature logging set"},
                        {'vantage_wind_cal_set': "Wind calibration set"},
                        {'vantage_temp_cal_set': "Temperature calibration set"},
                        {'vantage_hum_cal_set': "Humidity calibration set"},
                        {'vantage_archive_mem_clear': "Archive memory cleared"},
                        {'vantage_clear_log_max_tries': "Max retries exceeded while clearing log"},
                        {'vantage_inconsist_eeprom': "Inconsistent EEPROM calibration values"},
                        {'vantage_hardware_type_no_read': "Unable to read hardware type"},
                        {'vantage_eeprom_max_tries': "Max retries exceeded while getting EEPROM data"},
                    ],
                    'errors': {
                        'label': "Errors",
                        'items': [
                            {'vantage_serial_exception_read': "Serial exception on read"},
                            {'vantage_serial_exception_write': "Serial exception on write"},
                            {'vantage_socket_error': "Socket error while opening port"},
                            {'vantage_eth_no_conn': "Unable to connect to ethernet host"},
                            {'vantage_ip_read_error': "IP read error"},
                            {'vantage_ip_write_error': "IP write error"},
                            {'vantage_loop_try_error': "Retries while reading Loop data"},
                            {'vantage_dmpaft_try_error': "DMPAFT try error"},
                            {'vantage_unknown_bucket': "Unknown bucket type"},
                            {'vantage_unknown_loop': "Unknown LOOP packet type"}
                        ]
                    },
                },
                'fousb': {
                    'label': "FineOffset USB",
                    'items': [
                        {'fousb_read_block_change': "USB check: Bad reads"},
                        {'fousb_rain_count_dec': "Spurious rain counter decrements ignored"},
                        {'fousb_rain_count_wrap': "Rain counter wrap arounds"},
                        {'fousb_power_cycles_attempted': "Power cycles attempted"},
                        {'fousb_power_cycles_completed': "Power cycles completed"},
                        {'fousb_sync_to_station': "Synchronised to station"},
                        {'fousb_unex_sensor_clk_change': "Unexpected sensor clock change"},
                        {'fousb_setting_sensor_clk': "Sensor clock set"},
                        {'fousb_missed_interval': "Missed interval"},
                        {'fousb_unexpected_clock_change': "Unexpected station clock change"},
                        {'fousb_setting_stn_clk': "Station clock set"},
                        {'fousb_lost_log_sync': "Lost log synchronisation"}
                    ],
                    'errors': {
                        'label': "Errors",
                        'items': [
                            {'fousb_get_interval_fail': "Failed attempts to get archive interval"},
                            {'fousb_cannot_find_device': "Cannot find USB device"},
                            {'fousb_cannot_claim_usb': "Unable to claim USB interface"},
                            {'fousb_station_status': "Station status changes"}, # leave out and just display lines ?
                            {'fousb_get_obs_fail': "Failed to get observations"},
                            {'fousb_invalid_data': "Invalid data in records from station memory"},
                            {'fousb_get_rec_fail': "Failed to get records from station memory"},
                            {'fousb_invalid_data_while_sync': "Invalid delay while synchronising"},
                            {'fousb_lost_sync': "Lost synchronisation"},
                            {'fousb_unex_ptr_change': "Unexpected pointer change"},
                            {'fousb_changing_format': "Changing data format"},
                            {'fousb_unstable_read': "Unstable read"},
                            {'fousb_unrecog_magic_number': "Unrecognised magic number"},
                            {'fousb_magic_num_changed': "Magic number changed"}
                        ]
                    }
                },
                'acurite': {
                    'label': "Acurite",
                    'items': [
                        {'acurite_loop_max_tries_error': "Maximum retries to get LOOP data exceeded"},
                        {'acurite_rain_count_dec': "Rain counter decrement ignored"},
                    ],
                    'errors': {
                        'label': "Errors",
                        'items': [
                            {'acurite_fail_loop_attempt': "Failed attempts to get LOOP data"},
                            {'acurite_r3_read_fail': "R3 read failed"},
                            {'acurite_cannot_find_device': "Cannot find USB device"},
                            {'acurite_cannot_claim_usb': "Unable to claim USB interface"},
                            {'acurite_iface_release_fail': "Interface release failed"},
                            {'acurite_r1_bad_length': "R1 bad length"},
                            {'acurite_r1_bad_format': "R1 bad format"},
                            {'acurite_r1_no_sensors': "R1 no sensors found"},
                            {'acurite_r1_bogus_flavor': "R1 bogus message flavor"},
                            {'acurite_r1_bogus_final_byte': "R1 bogus final byte"},
                            {'acurite_r2_bad_length': "R2 bad length"},
                            {'acurite_r2_bad_format': "R2 bad format"},
                            {'acurite_r2_unkown_cal': "R2 unknown calibration constants"},
                            {'acurite_r2_const_changed': "R2 constants changed"},
                            {'acurite_r3_bad_value': "R3 bad value in row"},
                            {'acurite_r3_bad_length': "R3 bad length in row"},
                            {'acurite_r3_bad_format': "R3 bad format in row"}
                        ]
                    }
                },
                'te923': {
                    'label': "TE923",
                    'errors': {
                        'label': "Errors",
                        'items': [
                            {'te923_skip_dupe_ts': "Packets with duplicate timestamps skipped"},
                            {'te923_cannot_find_device': "Cannot find USB device"},
                            {'te923_cannot_claim_usb': "Unable to claim USB interface"},
                            {'te923_rel_iface_fail': "Interface release failed"},
                            {'te923_read_timeout': "Timeout while reading raw data"},
                            {'te923_wrong_num_bytes': "Read: wrong number of bytes"},
                            {'te923_write_wrong_bytes': "Write: acknowledgement got wrong number of bytes"},
                            {'te923_read_data_fail': "Failed attempts to read data"},
                            {'te923_write_data_fail': "Failed attempts to write data"},
                            {'te923_unrecog_mem_size': "Unrecognised memory size"},
                            {'te923_rec_index_exceeds_mem': "Record index exceeds memory size"},
                            {'te923_too_many_rec': "Too many records requested"},
                            {'te923_gen_rec_skip': "Generate records, record skipped"},
                            {'te923_no_data_at_add': "Get record, no data at address"},
                            {'te923_unrecog_interval': "Unrecognized archive interval"}
                        ]
                    }
                },
                'ultimeter': {
                    'label': "Ultimeter",
                    'items': [
                        {'ultimeter_set_time': "Set station time"},
                        {'ultimeter_set_year': "Set station year"},
                        {'ultimeter_set_logger_mode': "Set station to logger mode"},
                        {'ultimeter_set_modem_mode': "Set station to modem mode"},
                        {'ultimeter_readings_max_retries': "Maximum retries to get readings exceeded"},
                        {'acurite_rain_count_dec': "Rain counter decrement ignored"},
                    ],
                    'errors': {
                        'label': "Errors",
                        'items': [
                            {'ultimeter_get_time_fail': "Failed to get time"},
                            {'ultimeter_get_readings_fail': "Failed attempts to get readings"},
                            {'ultimeter_decode_fail': "Decode failed"}
                        ]
                    }
                },
                'wmr9x8': {
                    'label': "WMR9x8",
                    'items': [
                        {'wmr9x8_rx_wm918_data_packet': "WM-918 data packets received"}
                    ],
                    'errors': {
                        'label': "Errors",
                        'items': [
                            {'wmr9x8_invalid_packet': "Invalid data packet"}
                        ]
                    }
                },
                'wmr100': {
                    'label': "WMR100",
                    'items': [
                        {'wmr100_usb_report_max_retries': "Max retries exceeded while fetching USB reports"}
                    ],
                    'errors': {
                        'label': "Errors",
                        'items': [
                            {'wmr100_cannot_find_device': "Cannot find device"},
                            {'wmr100_cannot_claim_usb': "Unable to claim USB interface"},
                            {'wmr100_malformed_packet': "Malformed packet"},
                            {'wmr100_checksum_exception': "Exception while calculating checksum"},
                            {'wmr100_buffer_length_bad checksum': "Bad checksum on buffer"},
                            {'wmr100_unable_send_usb_ctl': "Unable to send USB control message"},
                            {'wmr100_bad_usb_report': "Bad USB report received"}
                        ]
                    }
                }
            }
        ]
    }
}

# locations to search for user specified loqwatch config file logwatch.conf
LOCATIONS = ('/home/weewx/bin/user',
             '/usr/share/weewx/user',
             '/Users/Shared/weewx/bin')
EXT_D_LOCATIONS = ('/home/weewx', '/etc/weewx/logwatch', '/Users/Shared/weewx')


class WeeWXLogwatchEngine(object):
    """Class to control processing and reporting on WeeWX logs.

    WeeWXLogwatchEngine creates LogwatchProcessor objects to ingest WeeWX
    generated log lines and produce the WeeWX logwatch report. An instance of
    class WeeWXLogwatchProcessor is created to ingest and report on log lines
    generated by the current WeeWX code base. Additional objects based on
    class LogwatchProcessor can be defined externally to ingest and report on
    log lines produced by WeeWX extensions or other addon code.

    Log lines are accepted one line at a time and passed to known
    LogwatchProcessor objects until a regex match is found. Unmatched lines are
    recorded by WeeWXLogwatchEngine. Regex matches are recorded by the
    individual LogwatchProcessor objects.

    Once all lines have been processed the WeeWX logwatch report is generated
    with each LogwatchProcessor object being called to contribute to the
    report.

    The regexes used to process log lines and the WeeWX report format can be
    controlled through a config dict used by each LogwatchProcessor based
    object. Reporting from each LogwatchProcessor object can be further
    extended with overridden/custom methods for more detailed reports.

    Class WeeWXLogwatchEngine can be called either from the logwatch system or
    directly by the user. When called directly by the user a file is used as
    the log source. When called by logwatch logwatch determines the lines to be
    passed to WeeWXLogwatchEngine based on the logwatch config and command line
    parameters.

    Level of detail. Logwatch supports a command line parameter 'detail' that
    sets the level of detail in the logwatch report. The detail parameter is a
    positive integer or high, med, low, which correspond to the integers 10,
    5, and 0, respectively. The WeeWX logwatch report uses the detail parameter
    as follows:

    0-2, low:    Clock report and summary counts only.
    3-4:         As per 0-2, low plus unmatched lines.
    5-7, medium: As per 3-4 plus itemised summaries.
    8-10, high:  As per 5-7, medium plus itemised error lines or the full
                 report.

    Input:
        logwatch_config_path: Path to WeeWX logwatch config file. Optional,
                              default is None.
        log_source: If omitted or None it is assumed that logwatch has invoked
                    WeeWXLogwatchEngine and stdin is used as the source for log
                    lines, otherwise log_source contains the path and file name
                    of a text file containing log lines to be processed.
                    Optional, default is None.
        detail:     Level of detail to include in the logwatch report. Optional,
                    positive integer 0-10 inclusive, default is 0.

    Output:
        WeeWX logwatch report sent to stdout.
    """

    def __init__(self, logwatch_config_path=None, log_source=None, detail=0):

        # record our start ts
        self.start_ts = time.time()
        # set our log source
        if log_source is None:
            # we have been invoked by logwatch so our log source is stdin
            self.log_source = sys.stdin
        else:
            # we have been invoked directly so our source will be a file like
            # object
            self.log_source = self.read_log(log_source)
        # set the level of detail required by logwatch
        self.detail = detail
        # now obtain a list of logwatch processor objects that we will use
        # first off the default WeeWX processor
        self.processor_objects = [WeeWXLogwatchProcessor(WEEWX_LOGWATCH_CONFIG_DEFAULT), ]
        # now add any that may be in ext.d
        ext_processor_objects = self.get_processors()
        self.processor_objects += ext_processor_objects

        # obtain an overall logwatch config dict by merging the configs for all
        # processor objects
        # initialise an empty config, we will merge into it
        self.logwatch_config = ConfigObj()
        # iterate over all processor objects
        for processor in self.processor_objects:
            # get the processors config, put it in a dict so we can find it and
            # then make it into a ConfigObj
            processor_config = ConfigObj({processor.__class__.__name__: processor.service_config})
            # merge the resulting ConfigObj into our overall config
            self.logwatch_config.merge(processor_config)

        # initialise a list to hold unmatched lines
        self.unmatched = []

        # setup the ignore list regex, since we want unique items in our list
        # use python sets
        # start with an empty set
        _ignore_set = set()
        # iterate over each process object we are using and add any ignore list
        # that it may have
        for processor in self.processor_objects:
            _processor_ignore_set = set(processor.ingest_config.get('ignore', []))
            _ignore_set = _ignore_set.union(_processor_ignore_set)
        # initialise a list to hold all of the compiled res for our ignore list
        self.ignore_regexs = []
        for check in _ignore_set:
            self.ignore_regexs.append(re.compile(check))

    @staticmethod
    def get_processors():
        """Find and obtain any addon logwatch processors."""

        # initialise a list hold any processor objects we find
        _processor_objects = []
        # see if we can find ext.d in one of the usual locations
        for ext in EXT_D_LOCATIONS:
            path = os.path.join(ext, 'ext.d')
            if os.path.exists(path) and os.path.isdir(path):
                break
        else:
            return _processor_objects
        # we are going to modify the path so save the current path so we can
        # restore it later
        old_path = sys.path
        # now look for any processors in ext.d
        try:
            # insert the path we are using to look for addon scripts into
            # sys.path
            sys.path.insert(0, path)
            # iterate over the contents of the directory where we are looking
            # for addon scripts
            for file in os.listdir(path):
                # get the full path to the item
                current = os.path.join(path, file)
                # check if its a file
                if os.path.isfile(current):
                    # we have a file, obtain just the name without the
                    # extension
                    base = os.path.basename(current)
                    stem = os.path.splitext(base)[0]
                    # now import the module being prepared to catch the error
                    # if the import fails
                    try:
                        __import__(stem)
                    except ImportError:
                        # inform the use and continue
                        print("could not import '%s'" % stem)
                        continue
                    # get the module object we just imported from the dict of
                    # imported modules
                    module = sys.modules[stem]
                    # now call the modules loader function which will give us
                    # an object instantiated from the addon class
                    loader = getattr(module, 'loader')
                    # add the object to our list of processor objects
                    _processor_objects.append(loader())
        finally:
            # we are done so restore the original path
            sys.path = old_path
        # return the list of processor objects we found
        return _processor_objects

    def run(self):
        """Process each line and produce our report.

        This is pretty straightforward, first ingest the log lines that logwatch
        feeds us then create the report.
        """

        # process the log lines
        self.ingest_lines()
        # produce the report
        self.generate_report()

    def ingest_lines(self):
        """Ingest each log line.

        Process each log line in turn passing it to each of the LogwatchProcessor
        objects we have until we obtain a 'match'. If the line is not matched
        add it to the unmatched list.
        """

        # iterate over all log lines from our source
        for line in self.log_source:
            # iterate over each of the processor objects we have passing the
            # line to each in turn
            for processor in self.processor_objects:
                # did we get a match from that object
                if processor.ingest_line(line) is True:
                    # we have a match, we are done so break out of the loop
                    break
            else:
                # did not find a match in any of our processor objects so is
                # this a line we can ignore?
                for ignore_regex in self.ignore_regexs:
                    if ignore_regex.search(line):
                        # yes we can ignore it, we are done so break out of the
                        # loop
                        break
                else:
                    # we did not find a match in any of our LogwatchProcessor
                    # object or the ignore list so save the line to the
                    # unmatched list for later reporting
                    self.unmatched.append(line)

    def generate_report(self):
        """Generate the WeeWX logwatch report.

        Generate the WeeWX logwatch report based upon the collected results,
        specific report requirements and the report definition in the
        [[report]] stanza in the WeeWX logwatch config.

        The clock report is specific to WeeWX and is not defined via the
        [[report]] stanza.

        Input:
            Nothing

        Output:
            The WeeWX logwatch report
        """

        # first display the WeeWX script version
        print("WeeWX logwatch script v%s" % WEEWX_LOGWATCH_VERSION)
        print()

        # now do the summary report
        is_summary_empty = True
        for processor in self.processor_objects:
            # call the generate_summary_report_method
            is_summary_empty = processor.generate_summary_report(detail=self.detail,
                                                                 is_empty=is_summary_empty)

        # now do any itemised reports but only if detail level is >= 5
        if self.detail >= 5:
            for processor in self.processor_objects:
                # call the generate_itemised_report_method
                processor.generate_itemised_report(detail=self.detail)

        # give each of the LogwatchProcessor objects the chance to provide any
        # any additional report output specific to themselves but only if
        # detail level is >= 5
        if self.detail >= 5:
            for processor in self.processor_objects:
                # call their generate_additional_report() method
                processor.generate_additional_report(detail=self.detail)

        # now do the unmatched lines but only if detail >= 3
        if self.detail >= 3 and len(self.unmatched) > 0:
            print()
            print("Unmatched lines:")
            for line in self.unmatched:
                print("  %s" % (line.rstrip('\n'),))

        # finally record how long we took
        elapsed = time.time() - self.start_ts
        print()
        print("WeeWX logwatch report generated in %0.3f seconds" % elapsed)

    @staticmethod
    def get_user_logwatch_config(logwatch_config_path=None):
        """Return user defined logwatch config if it exists.

        Look for logwatch.conf in /home/weewx/bin/user and
        /usr/share/weewx/user and if found return as a ConfigObj object.
        """

        # do we have a path
        if logwatch_config_path is not None:
            return ConfigObj(logwatch_config_path,
                             file_error=True,
                             encoding="utf-8")
        else:
            # no path provided so go looking in the usual places
            for directory in LOCATIONS:
                candidate = os.path.abspath(os.path.join(directory, 'logwatch.conf'))
                # does the candidate file exist, if so return its contents as a
                # ConfigObj object
                if os.path.isfile(candidate):
                    return ConfigObj(candidate, encoding="utf-8")
        # we could not find a longwatch config file so return None
        return ConfigObj({})

    @staticmethod
    def read_log(source):
        """Read log from external file.

        For testing and development only. Delete before release.
        """

        fh = open(source)
        for line in fh:
            yield line
        fh.close()


class LogwatchProcessor(object):
    """Base class to process log files.


    """

    def __init__(self, service_config):
        # save our config
        self.service_config = service_config

        # create a dict to hold our results
        self.results = {}

        # construct a dict of compiled regex we understand
        # first, initialise a dict to hold the compiled regex
        self.regexs = {}
        # populate the compiled 'increment' res
        if 'increment' in self.ingest_config:
            # add a placeholder for 'increment' results
            self.results['increment'] = {}
            # create a dict to hold the compiled res
            self.regexs['increment'] = {}
            # iterate over our 'increment' config compiling res and
            # initialising counts
            for var, filter_str in self.ingest_config['increment'].items():
                # compile the re and save it
                self.regexs['increment'][var] = re.compile(filter_str)
                # initialise the corresponding count
                self.results['increment'][var] = 0
        # populate the compiled 'sum' res
        if 'sum' in self.ingest_config:
            # add a placeholder for 'sum' results
            self.results['sum'] = {}
            # create a dict to hold the compiled res
            self.regexs['sum'] = {}
            # iterate over our 'sum' config compiling res and
            # initialising counts
            for var, filter_str in self.ingest_config['sum'].items():
                # compile the re and save it
                self.regexs['sum'][var] = re.compile(filter_str)
                # initialise the corresponding count
                self.results['sum'][var] = 0
        # populate the compiled 'itemised' res
        if 'itemised' in self.ingest_config:
            # add a placeholder for 'sum' results
            self.results['itemised'] = {}
            # create a dict to hold the compiled res
            self.regexs['itemised'] = {}
            # add any regexs in our 'itemised' stanza
            self.add_filters(self.ingest_config['itemised'],
                             self.regexs['itemised'])

    @property
    def ingest_config(self):
        """My ingest config."""

        return self.service_config.get('ingest', {})

    @property
    def report_config(self):
        """My ingest config."""

        return self.service_config.get('report', {})

    def add_filters(self, stanza, results_dict):
        """Recursively add compiled regex filters to a dict."""

        for keyword, value in stanza.items():
            if hasattr(value, 'items'):
                # we have another section, call ourselves
                if keyword not in results_dict:
                    results_dict[keyword] = {}
                self.add_filters(value, results_dict[keyword])
            else:
                # we have a keyword = value pair, just compile the regex and save
                results_dict[keyword] = re.compile(value)

    def ingest_line(self, line):
        """Process a log entry line.

        Ingest a log entry line looking for a match. If a match is found
        extract and save the relevant info. If a match is found return True,
        if no match is found return False.
        """

        # do we have any 'increment' regex's
        if 'increment' in self.regexs:
            # we have some regexs, so iterate over them
            for var, comp_regex in self.regexs['increment'].items():
                # now check if the regex finds a match
                if comp_regex.search(line):
                    # match found, so increment the relevant result
                    self.results['increment'][var] += 1
                    # since we have a match we can stop looking and return
                    return True
        # do we have any 'sum' regex's
        if 'sum' in self.regexs:
            # we have some regexs, so iterate over them
            for var, comp_regex in self.regexs['sum'].items():
                # now check if the regex finds a match, remember that 'sum'
                # regex's return a value
                z = comp_regex.search(line)
                if z:
                    # match found, so add found value to the relevant result
                    self.results['sum'][var] += int(z.groups()[0])
                    # since we have a match we can stop looking and return
                    return True
        # do we have any 'itemised' regex's
        if 'itemised' in self.regexs:
            # we have some 'itemised' regexs, so iterate over the sections
            for section_name, section_content in self.regexs['itemised'].items():
                # iterate over the items in each section
                if section_name not in self.results['itemised']:
                    self.results['itemised'][section_name] = {}
                our_results = self.results['itemised'][section_name]
                for regex_name, regex in section_content.items():
                    # do we have a key = value (compiled regex) pair or another dict
                    if not hasattr(regex, 'items'):
                        # it's a key = value (compiled regex) pair so just execute
                        # the regex and store the results if applicable
                        _match = regex.search(line)
                        if _match:
                            if len(_match.groups()) == 0:
                                if regex_name not in our_results:
                                    our_results[regex_name] = 1
                                else:
                                    our_results[regex_name] += 1
                            else:
                                if regex_name not in our_results:
                                    our_results[regex_name] = [_match.groups(), ]
                                else:
                                    our_results[regex_name] += [_match.groups(), ]
                            return True
                    else:
                        # we have a section, we only recognise an 'errors' section
                        if regex_name == 'errors':
                            if regex_name not in our_results:
                                our_results[regex_name] = {}
                            for sect_regex_name, sect_regex in regex.items():
                                if not hasattr(sect_regex, 'items'):
                                    # its a key = value (compiled regex) pair
                                    _match = sect_regex.search(line)
                                    if _match:
                                        if sect_regex_name in our_results[regex_name]:
                                            our_results[regex_name][sect_regex_name] += 1
                                        else:
                                            our_results[regex_name][sect_regex_name] = 1
                                        if 'lines' in our_results[regex_name]:
                                            our_results[regex_name]['lines'].append(line)
                                        else:
                                            our_results[regex_name]['lines'] = [line]
                                        return True
        # if we made it here we found no matches so return False
        return False

    def ingest_itemised(self, line, key, ):
        """Ingest an itemised regex."""

    def generate_summary_report(self, is_empty, detail=0):
        """Generate our contribution to the summary report."""

        # get the summary config from our report config
        summary_report_config = self.report_config.get('summary', [])
        # do we have any summary requirements
        if len(summary_report_config) > 0:
            # do we have a dict or a list?
            if hasattr(summary_report_config, 'items'):
                # its a dict
                for var, label in summary_report_config.items():
                    # if we have content for this item print it
                    result = self.get_count(var)
                    if result is not None and result > 0:
                        if is_empty:
                            print("Summary counts:")
                            is_empty = False
                        print("  %-45s %6d" % (label, result))
            else:
                # it's a list
                # iterate over each summary report item
                for summary_item_dict in summary_report_config:
                    for var, label in summary_item_dict.items():
                        # if we have content for this item print it
                        result = self.get_count(var)
                        if result is not None and result > 0:
                            if is_empty:
                                print("Summary counts:")
                                is_empty = False
                            print("  %-45s %6d" % (label, result))
        return is_empty

    def get_count(self, var):
        """Find a result in either 'increment' or 'sum' results."""

        # first look in increment
        if 'increment' in self.results and var in self.results['increment']:
            return self.results['increment'][var]
        elif 'sum' in self.results and var in self.results['sum']:
            return self.results['sum'][var]
        else:
            return None

    def generate_itemised_report(self, detail=0):
        """Generate any itemised reports I know about."""

        # TODO. check spacing particularly if no itemised report items
        if detail >= 5:
            # get my itemised report config
            itemised_report_config = self.report_config.get('itemised', [])
            # do we have any itemised report items
            if len(itemised_report_config) > 0:
                for itemised_item_config in itemised_report_config:
                    for item_name, item_config in itemised_item_config.items():
                        # do we have a specialist method to call for this section
                        _method_name = ''.join(('generate_', item_name, '_itemised_report'))
                        if hasattr(self, _method_name):
                            # we do so call it
                            getattr(self, _method_name)(item_config,
                                                        detail=detail)
                        else:
                            self.generate_generic_itemised_report(item_config,
                                                                  item_name,
                                                                  detail=detail)

    def generate_generic_itemised_report(self, generic_report_config, generic_name, detail=0):
        """Generate a generic itemised report."""

        _is_empty = True
        # first do the 'items'
        # get the 'items' config
        items_report_config = generic_report_config.get('items')
        # do we have any items?
        if items_report_config and len(items_report_config) > 0:
            # iterate over the entries
            for item_config in items_report_config:
                for item, data in item_config.items():
                    # TODO. Need cover for cases where 'increment', 'sum' or 'itemised' is not in self.results
                    if 'itemised' in self.results and self.results['itemised'].get(generic_name) is not None:
                        _results = self.results['itemised'][generic_name].get(item)
                        if _results is None:
                            _results = self.get_count(item)
                            if _results is None:
                                continue
                    else:
                        _results = self.get_count(item)
                        if _results is None:
                            continue
                    if isinstance(_results, list):
                        # we have a list, we don't know what to do with lists (we
                        # are only generic) so pass
                        pass
                    else:
                        # we have a number, so it's a simple label: number
                        # we have some 'item' results
                        if _is_empty:
                            print()
                            print("%s:" % generic_report_config.get('label', item))
                            _is_empty = False
                        print("    %-43s %6d" % (data, _results))
        # now do the errors if the required detail is sufficiently high
        if detail >= 8 and 'itemised' in self.results:
            self.generate_itemised_errors_report(generic_report_config,
                                                 self.results['itemised'].get(generic_name),
                                                 _is_empty)

    @staticmethod
    def generate_itemised_errors_report(parent_report_config, parent_results, is_parent_empty):
        """Generate the 'Errors' component of an itemised report."""

        is_errors_empty = True
        errors_report_config = parent_report_config.get("errors")
        if errors_report_config:
            # and do we have any results to report
            if parent_results is not None and len(parent_results.get('errors', {})) > 0:
                # we have some error results
                if is_parent_empty:
                    print()
                    # TODO. Need to obtain a sensible default for 'label'
                    print("%s:" % parent_report_config.get('label'))
                    is_parent_empty = False
                if is_errors_empty:
                    print("  %s:" % errors_report_config.get('label', 'Error summary'))
                    is_errors_empty = False
                errors_items_config = errors_report_config.get('items', {})
                for error_item_config in errors_items_config:
                    for item, data in error_item_config.items():
                        if parent_results['errors'].get(item) is not None:
                            print("    %-43s %6d" % (data, parent_results['errors'].get(item)))
                # now list any accumulated error lines
                if parent_results['errors'].get('lines') is not None:
                    # now print the error lines, fist a blank line for formatting
                    print("    %s:" % 'Error lines')
                    for error_line in parent_results['errors']['lines']:
                        print("      %-111s" % (error_line.rstrip(),))

    def generate_additional_report(self, detail=0):
        """Generate any additional report output specific to this filter."""

        pass


class WeeWXLogwatchProcessor(LogwatchProcessor):
    """Class to process core WeeWX log files.

    This class knows how to ingest and report on WeeWX log lines generated by
    the core WeeWX code. It does not know how to ingest or report on log lines
    generated by WeeWX extensions, add-ons or other custom code. A separate
    LogWatchProcessor based object should be defined and invoked to process
    such lines.
    """

    def __init__(self, filter_config_dict):
        # initialize my base class
        super(WeeWXLogwatchProcessor, self).__init__(filter_config_dict)

        # Whilst the filtering of logs for clock error data is simple, the
        # subsequent reporting is complex so clock error processing is handled
        # separately and not via the WeeWX logwatch config. Compile and save
        # the necessary regex.
        self.regexs['clock'] = re.compile("engine: Clock error is ([0-9,.-]+)")

    def ingest_line(self, line):
        """Process a log entry line.

        As well as doing the standard matching we also need to look for clock
        related lines. Call our parent's ingest_line, capturing the result and
        if necessary then checking for a 'clock match'. Return the appropriate
        True/False result depending on whether we had a match or not.
        """

        # call our parent's ingest_line method catching the result
        _match = super(WeeWXLogwatchProcessor, self).ingest_line(line)
        # did we find a match?
        if not _match:
            # There was no match so look for a 'clock match'. Our result will
            # be whether ot not we found a 'clock match'.
            return self.clock(line)
        else:
            # our parent did find a match so return it's result
            return _match

    def clock(self, line):
        """Process clock log lines"""

        _match = self.regexs['clock'].search(line)
        if _match:
            _result = float(_match.groups()[0])
            if 'clocksum' in self.results:
                self.results['clocksum'] += _result
                if _result < self.results['clockmin']:
                    self.results['clockmin'] = _result
                if _result > self.results['clockmax']:
                    self.results['clockmax'] = _result
                self.results['clockcount'] += 1
            else:
                self.results['clocksum'] = _result
                self.results['clockmin'] = 0
                self.results['clockmax'] = 0
                self.results['clockcount'] = 1
            return True
        return False

    def generate_summary_report(self, is_empty, detail=0):
        """Generate my portion of the summary report"""

        # TODO. Check clock operation with aurora, following does not seem right
        # Average station clock skew: 3.040
        # min: 0.000 max: 0.000 samples: 1

        # first do the clock if we have clock data
        if 'clockcount' in self.results and self.results['clockcount'] > 0:
            # calculate the average clock skew
            clock_skew = self.results['clocksum'] / self.results['clockcount']
            # print the results
            print("Average station clock skew: %.3f" % clock_skew)
            print("  min: %.3f max: %.3f samples: %d" % (self.results['clockmin'],
                                                         self.results['clockmax'],
                                                         self.results['clockcount']))
            print()

        # get the summary config from our report config
        summary_report_config = self.report_config.get('summary', [])
        # do we have any summary requirements
        if len(summary_report_config) > 0:
            # iterate over each summary report item
            for summary_item_dict in summary_report_config:
                for var, label in summary_item_dict.items():
                    # if we have content for this item print it
                    result = self.get_count(var)
                    if result is not None and result > 0:
                        if is_empty:
                            print("Summary counts:")
                            is_empty = False
                        print("  %-45s %6d" % (label, result))
        return is_empty

    def generate_restx_itemised_report(self, restx_report_config, detail=0):
        """Generate the restx itemised report.

        # do we have any items?
        if items_report_config and len(items_report_config) > 0:
            # iterate over the entries
            for item_config in items_report_config:
                for item, data in item_config.items():
                    # TODO. Need cover for cases where 'increment', 'sum' or 'itemised' is not in self.results
                    if 'itemised' in self.results and self.results['itemised'].get(generic_name) is not None:
                        _results = self.results['itemised'][generic_name].get(item)



        """

        _is_empty = True
        # first do the 'items'
        # get the 'items' config
        items_report_config = restx_report_config.get('items')
        # do we have any items?
        if items_report_config and len(items_report_config) > 0:
            # iterate over the entries
            for item_config in items_report_config:
                for item, data in item_config.items():
                    if self.results['itemised'].get('restx') is not None:
                        _results = self.results['itemised']['restx'].get(item)
                        if _results is not None and len(_results) > 0:
                            # we have some 'item' results
                            if _is_empty:
                                print()
                                print("%s:" % restx_report_config.get('label', item))
                                _is_empty = False
                            print("  %s:" % data)
                            _services = [z[0] for z in _results]
                            _unique_services = set(_services)
                            _res = {a: _services.count(a) for a in _unique_services}
                            for service, count in _res.items():
                                print("    %-43s %6d" % (service, count))
        # now do the errors if the required detail is sufficiently high
        if detail >= 8:
            self.generate_itemised_errors_report(restx_report_config,
                                                 self.results['itemised'].get('restx'),
                                                 _is_empty)

    def generate_image_generator_itemised_report(self, image_generator_report_config, detail=0):
        """Generate the image_generator itemised report."""

        _is_empty = True
        # first do the 'items'
        # get the 'items' config
        items_report_config = image_generator_report_config.get('items')
        # do we have any items?
        if items_report_config and len(items_report_config) > 0:
            # iterate over the entries
            for item_config in items_report_config:
                for item, data in item_config.items():
                    if self.results['itemised'].get('image_generator') is not None:
                        _results = self.results['itemised']['image_generator'].get(item)
                        if _results is None:
                            _results = self.get_count(item)
                            if _results is None:
                                continue
                    else:
                        _results = self.get_count(item)
                        if _results is None:
                            continue
                    if _results is not None:
                        # we have some 'item' results
                        if _is_empty:
                            print()
                            print("%s:" % image_generator_report_config.get('label', item))
                            _is_empty = False
                        print("    %-43s %6d" % (data, _results))
        # now do the errors if the required detail is sufficiently high
        if detail >= 8:
            self.generate_itemised_errors_report(image_generator_report_config,
                                                 self.results['itemised'].get('image_generator'),
                                                 _is_empty)

    def process_section(self, regexs, line, section, results):
        """"""

        for keyword, value in section.items():
            if not hasattr(value, 'items'):
                # its a key = value (compiled regex) pair
                if keyword in regexs:
                    _match = regexs[keyword].search(line)
                    if _match:
                        if keyword in results:
                            results[keyword] += 1
                        else:
                            results[keyword] = 1
                        if 'lines' in results:
                            results['lines'].append(line)
                        else:
                            results['lines'] = [line]
                        return True
            else:
                # it's a section so call ourself
                if keyword not in results:
                    results[keyword] = {}
                return self.process_section(regexs.get(keyword, {}), line, value, results[keyword])
        return False


description = """Analyse WeeWX logs and generate a logwatch report."""

usage = """weewx --help
       weewx --version
       weewx --logwatch-config=LOGWATCH_CONFIG_FILE
       weewx --source=LOG_SOURCE_FILE
       weewx --detail=LOGWATCH_DETAIL_LEVEL
"""

epilog = """This script will analyse WeeWX log entries and generate the WeeWX 
            portion of a logwatch system report."""


def main():
    """The main routine that kicks everything off.

    Can be run directly like a standard WeeWX utility or can be called as
    logwatch module. If called with o options then it is assumed that
    logwatch has made the call. Otherwise the options are processed and
    executed as applicable,
    """

    detail_lookup = {'low': 0, 'medium': 5, 'high': 10}

    # create a command line parser
    parser = optparse.OptionParser(description=description,
                                   usage=usage,
                                   epilog=epilog)

    # add the various options
    parser.add_option("--logwatch-config", dest="logwatch_config_path", type=str,
                      metavar="LOGWATCH_CONFIG_FILE",
                      help="Use WeeWX logwatch configuration file LOGWATCH_CONFIG_FILE.")
    parser.add_option("--log-source", dest="log_source", type=str,
                      metavar="LOG_SOURCE_FILE",
                      help="Read log entries from LOG_SOURCE_FILE.")
    # Would normally set a default value of 0 for detail_level but that
    # complicates determining whether logwatch called us or whether we were
    # invoked directly. Omit default and do some extract processing later to
    # work out a default for when we are invoked directly.
    parser.add_option("--detail", dest="detail_level", type=str,
                      metavar="LOGWATCH_DETAIL_LEVEL",
                      help="Logwatch detail level. Positive interger from 0 (least detail) "
                           "to 10 (most detail) or low, medium or high.")
    parser.add_option("--version", dest="version", action="store_true",
                      help="Display WeeWX logwatch script version number.")

    # now we are ready to parse the command line:
    (options, args) = parser.parse_args()

    # do we have any options or args?
    if all([v is None for v in options.__dict__.values()]) and len(args) == 0:
        # we have no options or args so logwatch must have called us so process
        # whatever log entries logwatch sends us
        # first obtain the detail level we are to use, this will have been set
        # by the logwatch --detail command line option but we can find it in in
        # the environment variable 'LOGWATCH_DETAIL_LEVEL'
        logwatch_detail = int(os.environ.get('LOGWATCH_DETAIL_LEVEL', 0))
        # first obtain a WeeWXLogwatchEngine object
        logwatch_controller = WeeWXLogwatchEngine(detail=logwatch_detail)
    else:
        # we have one or more options or one or more args so process them

        # display wee_import version info
        if options.version:
            print("WeeWX logwatch script version: %s" % WEEWX_LOGWATCH_VERSION)
            exit(0)

        # if we made it here we must be going to process some logs from a
        # non-logwatch source

        # get the detail level to be used
        try:
            logwatch_detail = int(options.detail_level)
            detail_str = options.detail_level
        except (TypeError, ValueError):
            # can't convert to an integer, perhaps it is low, medium or high or
            # was not specified
            # first try None
            if options.detail_level is None:
                logwatch_detail = 0
                detail_str = "LOW (0)"
            else:
                logwatch_detail = detail_lookup.get(options.detail_level.lower())
                if logwatch_detail is not None:
                    detail_str = "%s (%d)" % (options.detail_level.upper(),
                                              logwatch_detail)
                else:
                    logwatch_detail = 0
                    detail_str = "LOW (0)"
        # say what we are doing...and with what
        print("Running WeeWX logwatch script directly...")
        if options.logwatch_config_path is None:
            print("  using the default WeeWX logwatch config")
        else:
            print("  using WeeWX logwatch config file: %s" % options.logwatch_config_path)
        print("  log source is: %s" % options.log_source)
        print("  detail level is: %s" % detail_str)
        print()
        # obtain a WeeWXLogwatchEngine object
        logwatch_controller = WeeWXLogwatchEngine(log_source=options.log_source,
                                                  detail=logwatch_detail)
    # now call the run() method of our LogwatchController object
    logwatch_controller.run()


# execute our main code
if __name__ == "__main__":
    main()
